{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gibbs","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the documentation of the <code>gibbs</code> package.</p> <p><code>gibbs</code> is a package that help you scale your ML workers (or any python code) across processes and machines, asynchronously.</p> <p><code>gibbs</code> is :</p> <ul> <li>\u26a1\ufe0f Highly performant</li> <li>\ud83d\udd00 Asynchronous</li> <li>\ud83d\udc25 Easy-to-use</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#latest-version","title":"Latest version","text":"<p>You can install the latest stable version of the package directly from PyPi with :</p> <pre><code>pip install gibbs\n</code></pre>"},{"location":"#bleeding-edge-version","title":"Bleeding-edge version","text":"<p>To install the bleeding-edge version (<code>main</code>, not released), you can do :</p> <pre><code>pip install git+https://github.com/astariul/gibbs.git\n</code></pre>"},{"location":"#local-version","title":"Local version","text":"<p>For development purposes, you can clone the repository locally and install it manually :</p> <pre><code>git clone https://github.com/astariul/gibbs.git\ncd gibbs\npip install -e .\n</code></pre>"},{"location":"#extra-dependencies","title":"Extra dependencies","text":"<p>You can also install extras dependencies, for example :</p> <pre><code>pip install gibbs[docs]\n</code></pre> <p>Will install necessary dependencies for building the docs.</p> <p>List of extra dependencies :</p> <ul> <li><code>test</code> : Dependencies for running unit-tests.</li> <li><code>hook</code> : Dependencies for running pre-commit hooks.</li> <li><code>lint</code> : Dependencies for running linters and formatters.</li> <li><code>docs</code> : Dependencies for building the documentation.</li> <li><code>ex</code> : Dependencies for running the examples.</li> <li><code>dev</code> : <code>test</code> + <code>hook</code> + <code>lint</code> + <code>docs</code>.</li> <li><code>all</code> : All extra dependencies.</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>To contribute, install the package locally (see Installation), create your own branch, add your code (and tests, and documentation), and open a PR !</p>"},{"location":"#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>Pre-commit hooks are set to check the code added whenever you commit something.</p> <p>When you try to commit your code, hooks are automatically run, and if you code does not meet the quality required by linters, it will not be committed. You then have to fix your code and try to commit again !</p> <p>Important</p> <p>If you never ran the hooks before, install it with : <pre><code>pre-commit install\n</code></pre></p> <p>Info</p> <p>You can manually run the pre-commit hooks with : <pre><code>pre-commit run --all-files\n</code></pre></p>"},{"location":"#unit-tests","title":"Unit-tests","text":"<p>When you contribute, you need to make sure all the unit-tests pass. You should also add tests if necessary !</p> <p>You can run the tests with :</p> <pre><code>pytest\n</code></pre> <p>Info</p> <p>Pre-commit hooks will not run the tests, but it will automatically update the coverage badge !</p>"},{"location":"#documentation","title":"Documentation","text":"<p>When you contribute, make sure to keep the documentation up-to-date.</p> <p>You can visualize the documentation locally by running :</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#changing-the-port-used-by-gibbs","title":"Changing the port used by <code>gibbs</code>","text":"<p>By default, <code>gibbs</code> uses the port <code>5019</code> for the sockets the communicate.</p> <p>You can change this port by using the argument <code>gibbs_port</code> in the Worker constructor, and the argument <code>port</code> in the Hub constructor :</p> <pre><code>hub = Hub(port=6222)\n\nw = Worker(MyModel, gibbs_port=6222)\n</code></pre>"},{"location":"advanced/#passing-arguments-to-models-constructor","title":"Passing arguments to model's constructor","text":"<p>If your model requires arguments for the constructor (like in the example given in the Usage section) :</p> <pre><code>class MyAwesomeModel:\n    def __init__(self, wait_time=0.25):\n        super().__init__()\n        self.w = wait_time\n</code></pre> <p>You can just pass the arguments to the Worker (positional arguments or keyword arguments, both work) :</p> <pre><code># With positional argument\nw1 = Worker(MyAwesomeModel, 0.3)\n\n# With keyword argument\nw2 = Worker(MyAwesomeModel, wait_time=0.3)\n</code></pre> <p>Only a small list of keywords arguments are reserved for <code>gibbs</code>. Here is the exhaustive list :</p> <ul> <li><code>gibbs_host</code></li> <li><code>gibbs_port</code></li> <li><code>gibbs_heartbeat_interval</code></li> <li><code>gibbs_reset_after_n_miss</code></li> </ul>"},{"location":"advanced/#starting-workers-in-another-machine","title":"Starting workers in another machine","text":"<p>By default, <code>gibbs</code> workers try to connect to a Hub on the local machine (<code>localhost</code>).</p> <p>But you can change this behavior, to have workers running in another machine !</p> <p>To do this, simply start your worker with the appropriate host using the <code>gibbs_host</code> argument :</p> <pre><code>w = Worker(MyModel, gibbs_host=\"192.178.0.3\")\n</code></pre>"},{"location":"advanced/#retrials-timeouts","title":"Retrials &amp; timeouts","text":"<p>By default, the <code>request()</code> method of the Hub will indefinitely waits for a response from the worker.</p> <p>If instead you want to have a timeout, you can specify the timeout (in seconds) with the <code>gibbs_timeout</code> argument :</p> <pre><code>h = Hub()\nawait h.request(x, gibbs_timeout=0.4)\n</code></pre> <p>If the Hub doesn't receive any response from the worker within the specified timeout, a <code>asyncio.TimeoutError</code> exception is raised.</p> <p>You can also specify a number of retries with the argument <code>gibbs_retries</code> :</p> <pre><code>h = Hub()\nawait h.request(x, gibbs_timeout=2, gibbs_retries=3)\n</code></pre> <p>With this code, the Hub will try to send a request. If the Hub didn't receive an answer within 2 seconds, it will retry the request again, up to 3 times.</p> <p>Note</p> <p>You need to specify <code>gibbs_timeout</code> when using <code>gibbs_retries</code>, because there is no timeout by default !</p> <p>You can also specify <code>gibbs_retries=-1</code> for infinite retries !</p>"},{"location":"advanced/#logging","title":"Logging","text":"<p>Inside <code>gibbs</code>, the library <code>loguru</code> is used for logging.</p> <p>By default, the logger is disabled (so logging functions become no-op). If you want to see what's going on inside <code>gibbs</code> (for contributing or debugging for example), you can activate it :</p> <pre><code>from loguru import logger\n\nlogger.enable(\"gibbs\")\n# From here, logs will be displayed\n</code></pre> <p>You can also change the level of logs you want, the format, etc...</p> <pre><code>from loguru import logger\nimport sys\n\nlogger.enable(\"gibbs\")\nlogger.remove()\nlogger.add(sys.stderr, format=\"{time} {level} {message}\", level=\"INFO\")\n</code></pre> <p>Tip</p> <p>For more details, check out the <code>loguru</code> library !</p>"},{"location":"advanced/#changing-the-heartbeat-interval","title":"Changing the heartbeat interval","text":"<p>By default, the heartbeat interval is set to one second.</p> <p>You can change this value by using the argument <code>gibbs_heartbeat_interval</code> in the Worker constructor, and the argument <code>heartbeat_interval</code> in the Hub constructor :</p> <pre><code>hub = Hub(heartbeat_interval=10)\n\nw = Worker(MyModel, gibbs_heartbeat_interval=10)\n</code></pre> <p>Warning</p> <p>Make sure that both the Hub and the workers have the same value for the heartbeat interval, otherwise they might have synchronisation issues !</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Warning</p> <p>This page contains advanced technical details about <code>gibbs</code>. You can probably skip it if you just want to use the library.</p>"},{"location":"architecture/#tooling","title":"Tooling","text":"<p><code>gibbs</code> relies on the <code>zmq</code> library for communication between the hub and the workers.</p> <p><code>zmq</code> is a low-level networking library, providing us with TCP sockets. This gives us performances, and the ability to have workers on different machines.</p>"},{"location":"architecture/#pattern","title":"Pattern","text":"<p><code>gibbs</code> implement a modified version of the Paranoid Pirate Pattern.</p> <p>You can read more about the Paranoid Pirate Pattern in the zmq guide. But basically :</p> <ul> <li>It is a reliable pattern (it can handle failures)</li> <li>It relies on the REQUEST - REPLY sockets (and their asynchronous equivalent : ROUTER - DEALER)</li> <li>It automatically balance requests across workers as they come</li> </ul> <p>Here is a schema for the Paranoid Pirate Pattern implemented in <code>gibbs</code> :</p> <p></p> <p>Tip</p> <p>As you can see the the original Paranoid Pirate Pattern is slightly modified : the clients and the queue are merged into a single component, called \"Hub\".</p> <p>Let's see how these components interact with each other to deal with parallel requests :</p> <p></p> <p>The Hub simply keeps a list of workers that are ready, and send incoming requests to one of the ready worker.</p> <p>Each worker deal with the request it receives. So with two workers, we can deal with two requests in parallel, as shown in the figure above.</p> <p>When receiving the response from the worker, the Hub marks it as ready again.</p>"},{"location":"architecture/#heartbeat","title":"Heartbeat","text":"<p>In the zmq guide, the Paranoid Pirate Pattern implements a One-way heartbeat.</p> <p>In <code>gibbs</code> though, the heartbeat is implemented as a Ping-pong heartbeat.</p> <p>Question</p> <p>Heartbeat is necessary to have robustness, in case of workers or Hub crash.</p> <p>Here is how heartbeat works :</p> <p></p> <p>The workers always initiate the heartbeat (ping), and the hub answer it (pong).</p> <p>If the worker keeps sending pings but does not receive pongs, we know the Hub is dead. In this case the worker will try to reconnect his socket. So when the Hub is restarted, the worker will automatically reconnect.</p> <p>If the Hub didn't receive a heartbeat from some time, we know this worker is dead. In this case the worker is removed from the list of workers ready, so no requests are sent to this worker.</p> <p>Warning</p> <p>There is a small time interval where a worker can die and the Hub still thinks it's alive. If a request is sent in this interval, the request will fail. To solve this, you can check the section about automatic retrials.</p>"},{"location":"architecture/#graceful-termination","title":"Graceful termination","text":"<p>In <code>gibbs</code>, the workers terminate cleanly when interrupted with a <code>CTRL-C</code> or another signal such as <code>SIGTERM</code>. By default, these signals simply kill the process, but in our case this is detrimental : if the worker took a request, we want this request to be fully treated, otherwise it is lost.</p> <p>If a worker took a request and then receive a signal to shut down, it will first process the request and send back the response before shutting down.</p> <p>Tip</p> <p>If you don't want your worker to end gracefully, you can always send a <code>SIGKILL</code>.</p> <p>To have this feature, the workers uses another socket internally, and uses polling to get whatever comes first (request or termination signal) :</p> <p></p> <p>So if a request comes first, the worker will first deal with the request before dealing with the termination signal (shutting down).</p>"},{"location":"code_ref/","title":"Code reference","text":""},{"location":"code_ref/#api","title":"API","text":""},{"location":"code_ref/#gibbs.hub.Hub","title":"<code>Hub</code>","text":"<p>Class acting as a hub for all the requests to send. All requests sent through this class will be automatically dispatched to connected workers, will wait for the responses and return it.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port number to use for the sockets. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>heartbeat_interval</code> <code>float</code> <p>Heartbeat interval used by the workers, in seconds. Defaults to DEFAULT_HEARTBEAT_INTERVAL.</p> <code>DEFAULT_HEARTBEAT_INTERVAL</code> <code>resp_buffer_size</code> <code>int</code> <p>Maximum response buffer size. Defaults to RESPONSE_BUFFER_SIZE.</p> <code>RESPONSE_BUFFER_SIZE</code> Source code in <code>gibbs/hub.py</code> <pre><code>class Hub:\n    \"\"\"Class acting as a hub for all the requests to send. All requests sent\n    through this class will be automatically dispatched to connected workers,\n    will wait for the responses and return it.\n\n    Args:\n        port (int): Port number to use for the sockets. Defaults to\n            DEFAULT_PORT.\n        heartbeat_interval (float): Heartbeat interval used by the\n            workers, in seconds. Defaults to DEFAULT_HEARTBEAT_INTERVAL.\n        resp_buffer_size (int): Maximum response buffer size. Defaults\n            to RESPONSE_BUFFER_SIZE.\n    \"\"\"\n\n    def __init__(\n        self,\n        port: int = DEFAULT_PORT,\n        heartbeat_interval: float = DEFAULT_HEARTBEAT_INTERVAL,\n        resp_buffer_size: int = RESPONSE_BUFFER_SIZE,\n    ):\n        super().__init__()\n\n        self.port = port\n        self.heartbeat_t = heartbeat_interval\n        self.socket = None\n        self.w_manager = None\n        self.req_manager = RequestManager(resp_buffer_size=resp_buffer_size)\n\n    async def receive_loop(self):\n        \"\"\"Infinite loop for receiving responses from the workers.\"\"\"\n        while True:\n            # Receive stuff\n            logger.debug(\"Receiving...\")\n            address, *frames = await self.socket.recv_multipart()\n            logger.debug(f\"Received something from worker #{address}\")\n\n            # Since we received a response from this worker, it means it's ready for more !\n            await self.w_manager.reckon(address)\n\n            if len(frames) == 1:\n                # Answer the Ping\n                logger.debug(\"Answering the ping\")\n                await self.socket.send_multipart([address, b\"\", PONG])\n                continue\n\n            _, resp = frames\n            req_id, code, res = msgpack.unpackb(resp)\n            logger.debug(f\"Received response from request #{req_id}\")\n\n            self.req_manager.store(req_id, code, res)\n\n    def _start_if_not_started(self):\n        \"\"\"Helper method to ensure everything is properly started (socket is\n        initialized, receiving loop is started, etc...).\n        \"\"\"\n        if self.socket is None:\n            # Create what we need here in this process/context\n            context = zmq.asyncio.Context()\n            self.socket = context.socket(zmq.ROUTER)\n            self.socket.bind(f\"tcp://*:{self.port}\")\n            self.w_manager = WorkerManager(heartbeat_interval=self.heartbeat_t)\n\n            # Fire and forget : infinite loop, taking care of receiving stuff from the socket\n            logger.info(\"Starting receiving loop...\")\n            asyncio.create_task(self.receive_loop())\n\n    async def _request(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Raw method to send a request. This method will do the following :\n         * Start the receiving loop if it was not started\n         * Get the address of the next worker ready (blocking)\n         * Send the request to the worker\n         * Wait for the response (blocking)\n         * Return the result\n\n        Args:\n            *args: Positional arguments for the request.\n            **kwargs: Keywords arguments for the request.\n\n        Raises:\n            UserCodeException: Exception raised if an exception was raised inside\n                user-defined code on the worker side.\n\n        Returns:\n            Any: The response for the request.\n        \"\"\"\n        # Before anything, if the receiving loop was not started, start it\n        self._start_if_not_started()\n\n        # Assign a unique ID to the request\n        req_id = uuid.uuid4().hex\n\n        # Let the manager know that we are waiting for this request\n        logger.debug(f\"Pinning request #{req_id}\")\n        self.req_manager.pin(req_id)\n\n        # Send the request\n        address = await self.w_manager.get_next_worker()\n        logger.debug(f\"Sending request #{req_id} to worker #{address}\")\n        await self.socket.send_multipart([address, b\"\", msgpack.packb([req_id, args, kwargs])])\n\n        # Wait until we receive the response\n        code, res = await self.req_manager.wait_for(req_id)\n        logger.debug(f\"Received result for request #{req_id}\")\n\n        # Depending on what is the response, deal with it properly\n        if code == CODE_FAILURE:\n            raise UserCodeException(res)\n        else:\n            return res\n\n    async def request(self, *args: Any, gibbs_timeout: float = None, gibbs_retries: int = 0, **kwargs: Any) -&gt; Any:\n        \"\"\"Main method, used to send a request to workers and get the result.\n\n        This method is a wrapper around `_request`, providing additional\n        functionalities :\n         * Timeout\n         * Automatic retries\n\n        Args:\n            *args: Positional arguments for the request.\n            gibbs_timeout (float): Timeout for the request, in seconds.\n                If `None` is given, block until the request is complete.\n                Defaults to None.\n            gibbs_retries (int): Number of retries. This argument is\n                used only if `gibbs_timeout` is not `None`. If `-1` is given,\n                indefinitely retry. Defaults to 0.\n            **kwargs: Keywords arguments for the request.\n\n        Raises:\n            asyncio.TimeoutError: Error raised if no response is received within\n                the given timeout.\n\n        Returns:\n            Any: The response for the request.\n        \"\"\"\n        try:\n            return await asyncio.wait_for(self._request(*args, **kwargs), timeout=gibbs_timeout)\n        except asyncio.TimeoutError:\n            if gibbs_retries == 0:\n                logger.error(f\"Request failed : no response received within {gibbs_timeout}s\")\n                raise\n            else:\n                retries_left = max(gibbs_retries - 1, -1)\n                logger.warning(\n                    f\"Request failed : no response received within {gibbs_timeout}s. Retrying {retries_left} times\"\n                )\n                return await self.request(*args, gibbs_timeout=gibbs_timeout, gibbs_retries=retries_left, **kwargs)\n\n    def __del__(self):\n        if self.socket is not None:\n            self.socket.close()\n</code></pre>"},{"location":"code_ref/#gibbs.hub.Hub.receive_loop","title":"<code>receive_loop()</code>  <code>async</code>","text":"<p>Infinite loop for receiving responses from the workers.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def receive_loop(self):\n    \"\"\"Infinite loop for receiving responses from the workers.\"\"\"\n    while True:\n        # Receive stuff\n        logger.debug(\"Receiving...\")\n        address, *frames = await self.socket.recv_multipart()\n        logger.debug(f\"Received something from worker #{address}\")\n\n        # Since we received a response from this worker, it means it's ready for more !\n        await self.w_manager.reckon(address)\n\n        if len(frames) == 1:\n            # Answer the Ping\n            logger.debug(\"Answering the ping\")\n            await self.socket.send_multipart([address, b\"\", PONG])\n            continue\n\n        _, resp = frames\n        req_id, code, res = msgpack.unpackb(resp)\n        logger.debug(f\"Received response from request #{req_id}\")\n\n        self.req_manager.store(req_id, code, res)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.Hub.request","title":"<code>request(*args, gibbs_timeout=None, gibbs_retries=0, **kwargs)</code>  <code>async</code>","text":"<p>Main method, used to send a request to workers and get the result.</p> <p>This method is a wrapper around <code>_request</code>, providing additional functionalities :  * Timeout  * Automatic retries</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments for the request.</p> <code>()</code> <code>gibbs_timeout</code> <code>float</code> <p>Timeout for the request, in seconds. If <code>None</code> is given, block until the request is complete. Defaults to None.</p> <code>None</code> <code>gibbs_retries</code> <code>int</code> <p>Number of retries. This argument is used only if <code>gibbs_timeout</code> is not <code>None</code>. If <code>-1</code> is given, indefinitely retry. Defaults to 0.</p> <code>0</code> <code>**kwargs</code> <code>Any</code> <p>Keywords arguments for the request.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>Error raised if no response is received within the given timeout.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response for the request.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def request(self, *args: Any, gibbs_timeout: float = None, gibbs_retries: int = 0, **kwargs: Any) -&gt; Any:\n    \"\"\"Main method, used to send a request to workers and get the result.\n\n    This method is a wrapper around `_request`, providing additional\n    functionalities :\n     * Timeout\n     * Automatic retries\n\n    Args:\n        *args: Positional arguments for the request.\n        gibbs_timeout (float): Timeout for the request, in seconds.\n            If `None` is given, block until the request is complete.\n            Defaults to None.\n        gibbs_retries (int): Number of retries. This argument is\n            used only if `gibbs_timeout` is not `None`. If `-1` is given,\n            indefinitely retry. Defaults to 0.\n        **kwargs: Keywords arguments for the request.\n\n    Raises:\n        asyncio.TimeoutError: Error raised if no response is received within\n            the given timeout.\n\n    Returns:\n        Any: The response for the request.\n    \"\"\"\n    try:\n        return await asyncio.wait_for(self._request(*args, **kwargs), timeout=gibbs_timeout)\n    except asyncio.TimeoutError:\n        if gibbs_retries == 0:\n            logger.error(f\"Request failed : no response received within {gibbs_timeout}s\")\n            raise\n        else:\n            retries_left = max(gibbs_retries - 1, -1)\n            logger.warning(\n                f\"Request failed : no response received within {gibbs_timeout}s. Retrying {retries_left} times\"\n            )\n            return await self.request(*args, gibbs_timeout=gibbs_timeout, gibbs_retries=retries_left, **kwargs)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager","title":"<code>RequestManager</code>","text":"<p>A helper class that takes care of storing responses and waiting for the right response.</p> <p>Parameters:</p> Name Type Description Default <code>resp_buffer_size</code> <code>int</code> <p>Maximum size of the response buffer.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class RequestManager:\n    \"\"\"A helper class that takes care of storing responses and waiting for the\n    right response.\n\n    Args:\n        resp_buffer_size (int): Maximum size of the response buffer.\n    \"\"\"\n\n    def __init__(self, resp_buffer_size: int):\n        super().__init__()\n\n        self.resp_buffer_size = resp_buffer_size\n\n        self.responses = {}\n        self.req_states = {}\n\n    def pin(self, req_id: str):\n        \"\"\"Pin a request ID. This is a necessary step when sending a request,\n        so that the request can be awaited until a response is received.\n        This method should be called for each `req_id` before calling `wait_for`.\n\n        Args:\n            req_id (str): Request unique identifier.\n        \"\"\"\n        self.req_states[req_id] = asyncio.Event()\n\n        # Ensure we don't store too many requests\n        if len(self.req_states) &gt; self.resp_buffer_size:\n            # If it's the case, forget the oldest one\n            k = list(self.req_states.keys())[0]\n            logger.warning(f\"Response buffer overflow (&gt;{self.resp_buffer_size}). Forgetting oldest request : {k}\")\n            self.req_states.pop(k)\n            self.responses.pop(k, None)\n\n    async def wait_for(self, req_id: str) -&gt; Tuple[int, Any]:\n        \"\"\"Async method that waits until we received the response corresponding\n        to the given request ID.\n\n        The method `pin` should be called before waiting with this method.\n\n        Args:\n            req_id (str): Request unique identifier.\n\n        Raises:\n            KeyError: Exception raised if the request wasn't registered previously.\n\n        Returns:\n            Tuple[int, Any]: Code and content of the received response.\n        \"\"\"\n        if req_id not in self.req_states:\n            raise KeyError(f\"Request #{req_id} was not pinned, or was removed because of buffer overflow\")\n\n        # Wait for the receiving loop to receive the response\n        await self.req_states[req_id].wait()\n\n        # Once we get it, access the result\n        r = self.responses.pop(req_id)\n\n        # Don't forget to remove the event\n        self.req_states.pop(req_id)\n\n        return r.code, r.content\n\n    def store(self, req_id: str, code: int, response: Any):\n        \"\"\"Store a response, to be consumed later.\n\n        Args:\n            req_id (str): Request unique identifier.\n            code (int): Code of the response.\n            response (Any): Content of the response.\n        \"\"\"\n        # Store the response if the req_id is recognized\n        if req_id in self.req_states:\n            self.responses[req_id] = Response(code, response)\n\n            # Notify that we received the response\n            self.req_states[req_id].set()\n        else:\n            logger.warning(\n                f\"Request #{req_id} was previously removed from response buffer. \"\n                f\"Ignoring the response from this request...\"\n            )\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.pin","title":"<code>pin(req_id)</code>","text":"<p>Pin a request ID. This is a necessary step when sending a request, so that the request can be awaited until a response is received. This method should be called for each <code>req_id</code> before calling <code>wait_for</code>.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>def pin(self, req_id: str):\n    \"\"\"Pin a request ID. This is a necessary step when sending a request,\n    so that the request can be awaited until a response is received.\n    This method should be called for each `req_id` before calling `wait_for`.\n\n    Args:\n        req_id (str): Request unique identifier.\n    \"\"\"\n    self.req_states[req_id] = asyncio.Event()\n\n    # Ensure we don't store too many requests\n    if len(self.req_states) &gt; self.resp_buffer_size:\n        # If it's the case, forget the oldest one\n        k = list(self.req_states.keys())[0]\n        logger.warning(f\"Response buffer overflow (&gt;{self.resp_buffer_size}). Forgetting oldest request : {k}\")\n        self.req_states.pop(k)\n        self.responses.pop(k, None)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.store","title":"<code>store(req_id, code, response)</code>","text":"<p>Store a response, to be consumed later.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required <code>code</code> <code>int</code> <p>Code of the response.</p> required <code>response</code> <code>Any</code> <p>Content of the response.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>def store(self, req_id: str, code: int, response: Any):\n    \"\"\"Store a response, to be consumed later.\n\n    Args:\n        req_id (str): Request unique identifier.\n        code (int): Code of the response.\n        response (Any): Content of the response.\n    \"\"\"\n    # Store the response if the req_id is recognized\n    if req_id in self.req_states:\n        self.responses[req_id] = Response(code, response)\n\n        # Notify that we received the response\n        self.req_states[req_id].set()\n    else:\n        logger.warning(\n            f\"Request #{req_id} was previously removed from response buffer. \"\n            f\"Ignoring the response from this request...\"\n        )\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.wait_for","title":"<code>wait_for(req_id)</code>  <code>async</code>","text":"<p>Async method that waits until we received the response corresponding to the given request ID.</p> <p>The method <code>pin</code> should be called before waiting with this method.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>Exception raised if the request wasn't registered previously.</p> <p>Returns:</p> Type Description <code>Tuple[int, Any]</code> <p>Tuple[int, Any]: Code and content of the received response.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def wait_for(self, req_id: str) -&gt; Tuple[int, Any]:\n    \"\"\"Async method that waits until we received the response corresponding\n    to the given request ID.\n\n    The method `pin` should be called before waiting with this method.\n\n    Args:\n        req_id (str): Request unique identifier.\n\n    Raises:\n        KeyError: Exception raised if the request wasn't registered previously.\n\n    Returns:\n        Tuple[int, Any]: Code and content of the received response.\n    \"\"\"\n    if req_id not in self.req_states:\n        raise KeyError(f\"Request #{req_id} was not pinned, or was removed because of buffer overflow\")\n\n    # Wait for the receiving loop to receive the response\n    await self.req_states[req_id].wait()\n\n    # Once we get it, access the result\n    r = self.responses.pop(req_id)\n\n    # Don't forget to remove the event\n    self.req_states.pop(req_id)\n\n    return r.code, r.content\n</code></pre>"},{"location":"code_ref/#gibbs.hub.UserCodeException","title":"<code>UserCodeException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom Exception for user-defined catched errors.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>Traceback returned by the worker.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class UserCodeException(Exception):\n    \"\"\"Custom Exception for user-defined catched errors.\n\n    Args:\n        t (str): Traceback returned by the worker.\n    \"\"\"\n\n    def __init__(self, t: str):\n        super().__init__(f\"Exception raised in user-defined code. Traceback :\\n{t}\")\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager","title":"<code>WorkerManager</code>","text":"<p>A helper class that takes care of managing workers. Workers' address can be registered as available, and this class will make sure to return address of workers that are available and alive.</p> <p>A worker is considered as dead if we didn't receive any heartbeat within a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>heartbeat_interval</code> <code>float</code> <p>Interval of time (in seconds) after which we consider a worker to be dead.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class WorkerManager:\n    \"\"\"A helper class that takes care of managing workers.\n    Workers' address can be registered as available, and this class will make\n    sure to return address of workers that are available and alive.\n\n    A worker is considered as dead if we didn't receive any heartbeat within a\n    given interval.\n\n    Args:\n        heartbeat_interval (float): Interval of time (in seconds) after which we\n            consider a worker to be dead.\n    \"\"\"\n\n    def __init__(self, heartbeat_interval: float):\n        super().__init__()\n\n        self.heartbeat_t = heartbeat_interval\n\n        self.w_ts = {}\n        self.w_access = asyncio.Condition()\n\n    async def reckon(self, address: str):\n        \"\"\"Register the given address as available.\n\n        Args:\n            address (str): Address of the worker to register as available.\n        \"\"\"\n        async with self.w_access:\n            self.w_ts[address] = time.time()\n            self.w_access.notify()\n\n    async def get_next_worker(self) -&gt; str:\n        \"\"\"Retrieve the next available and alive worker's address.\n\n        Returns:\n            str: Address of the available and alive worker.\n        \"\"\"\n        async with self.w_access:\n            # Iterate workers until we find one that was alive recently\n            w_alive = False\n            while not w_alive:\n                # If no workers are available, wait...\n                if not self.w_ts:\n                    await self.w_access.wait()\n\n                address, ts = self.w_ts.popitem()\n                w_alive = time.time() - ts &lt; self.heartbeat_t\n\n            return address\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager.get_next_worker","title":"<code>get_next_worker()</code>  <code>async</code>","text":"<p>Retrieve the next available and alive worker's address.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Address of the available and alive worker.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def get_next_worker(self) -&gt; str:\n    \"\"\"Retrieve the next available and alive worker's address.\n\n    Returns:\n        str: Address of the available and alive worker.\n    \"\"\"\n    async with self.w_access:\n        # Iterate workers until we find one that was alive recently\n        w_alive = False\n        while not w_alive:\n            # If no workers are available, wait...\n            if not self.w_ts:\n                await self.w_access.wait()\n\n            address, ts = self.w_ts.popitem()\n            w_alive = time.time() - ts &lt; self.heartbeat_t\n\n        return address\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager.reckon","title":"<code>reckon(address)</code>  <code>async</code>","text":"<p>Register the given address as available.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address of the worker to register as available.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>async def reckon(self, address: str):\n    \"\"\"Register the given address as available.\n\n    Args:\n        address (str): Address of the worker to register as available.\n    \"\"\"\n    async with self.w_access:\n        self.w_ts[address] = time.time()\n        self.w_access.notify()\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker","title":"<code>Worker</code>","text":"<p>               Bases: <code>Process</code></p> <p>Define a worker process. This worker process indefinitely waits for requests on a socket. Upon receiving a request, it processes it with the worker class provided, and return the response.</p> <p>After creating the Worker object, you have 2 different ways to run it :  * <code>worker.run()</code> : It will run in the current process directly (blocking,     infinite loop).  * <code>worker.start()</code> : It will start a different process and start the code     there (non-blocking).</p> <p>Parameters:</p> Name Type Description Default <code>worker_cls</code> <code>Callable</code> <p>Worker class containing the code that will be used to process requests.</p> required <code>gibbs_host</code> <code>str</code> <p>Host of the Hub. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>gibbs_port</code> <code>int</code> <p>Port of the Hub. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>gibbs_heartbeat_interval</code> <code>float</code> <p>Heartbeat interval between the worker and the Hub. Defaults to DEFAULT_HEARTBEAT_INTERVAL.</p> <code>DEFAULT_HEARTBEAT_INTERVAL</code> <code>gibbs_reset_after_n_miss</code> <code>int</code> <p>Number of missed heartbeats allowed before hard-resetting the socket and retrying. Defaults to DEFAULT_RESET_AFTER_N_MISS.</p> <code>DEFAULT_RESET_AFTER_N_MISS</code> Source code in <code>gibbs/worker.py</code> <pre><code>class Worker(Process):\n    \"\"\"Define a worker process. This worker process indefinitely waits for\n    requests on a socket. Upon receiving a request, it processes it with the\n    worker class provided, and return the response.\n\n    After creating the Worker object, you have 2 different ways to run it :\n     * `worker.run()` : It will run in the current process directly (blocking,\n        infinite loop).\n     * `worker.start()` : It will start a different process and start the code\n        there (non-blocking).\n\n    Args:\n        worker_cls (Callable): Worker class containing the code that will be used\n            to process requests.\n        gibbs_host (str): Host of the Hub. Defaults to \"localhost\".\n        gibbs_port (int): Port of the Hub. Defaults to DEFAULT_PORT.\n        gibbs_heartbeat_interval (float): Heartbeat interval between the\n            worker and the Hub. Defaults to DEFAULT_HEARTBEAT_INTERVAL.\n        gibbs_reset_after_n_miss (int): Number of missed heartbeats\n            allowed before hard-resetting the socket and retrying. Defaults to\n            DEFAULT_RESET_AFTER_N_MISS.\n    \"\"\"\n\n    def __init__(\n        self,\n        worker_cls: Callable,\n        *args: Any,\n        gibbs_host: str = \"localhost\",\n        gibbs_port: int = DEFAULT_PORT,\n        gibbs_heartbeat_interval: float = DEFAULT_HEARTBEAT_INTERVAL,\n        gibbs_reset_after_n_miss: int = DEFAULT_RESET_AFTER_N_MISS,\n        **kwargs: Any,\n    ):\n        super().__init__()\n\n        self.worker_cls = worker_cls\n        self.worker_args = args\n        self.worker_kwargs = kwargs\n\n        self.identity = uuid.uuid4().hex\n        self.host = gibbs_host\n        self.port = gibbs_port\n        self.heartbeat_t = gibbs_heartbeat_interval\n        self.reset_n_miss = gibbs_reset_after_n_miss\n\n        self.waiting_pong = 0\n\n    def create_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n        \"\"\"Helper method to create a socket, setting its identity and connecting\n        to the Hub.\n\n        Args:\n            context (zmq.Context): ZMQ context to use.\n\n        Returns:\n            zmq.Socket: Initialized and connected socket, ready to use.\n        \"\"\"\n        # Create the socket, set its identity\n        socket = context.socket(zmq.DEALER)\n        socket.setsockopt_string(zmq.IDENTITY, self.identity)\n\n        # Connect to the Hub\n        socket.connect(f\"tcp://{self.host}:{self.port}\")\n\n        return socket\n\n    def create_term_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n        \"\"\"Helper method to create a termination socket.\n\n        Basically it creates 2 sockets, bind/connect them together. One socket\n        will be used to send a termination signal, and the other is returned and\n        used to receive the termination signal.\n\n        Args:\n            context (zmq.Context): ZMQ context to use.\n\n        Returns:\n            zmq.Socket: Initialized and connected socket, ready to use.\n        \"\"\"\n        # Create the socket than will send the termination ping\n        term_snd_socket = context.socket(zmq.REQ)\n        port = term_snd_socket.bind_to_random_port(\"tcp://127.0.0.1\")\n\n        # Then define the behavior on how to send the termination ping\n        def send_term(*args, **kwargs):\n            logger.debug(\"Sending termination ping...\")\n            # Send something on the termination socket, it doesn't matter what\n            term_snd_socket.send(PING)\n\n        # We send the termination ping upon receiving these signals\n        signal.signal(signal.SIGTERM, send_term)\n        signal.signal(signal.SIGINT, send_term)\n\n        # And finally create the socket that we will use to receive the termination signal\n        term_rcv_socket = context.socket(zmq.REP)\n        term_rcv_socket.connect(f\"tcp://localhost:{port}\")\n\n        return term_rcv_socket\n\n    def reset_socket(self, socket: zmq.Socket, context: zmq.Context, poller: zmq.Poller) -&gt; zmq.Socket:\n        \"\"\"Helper method to reset the given socket.\n\n        This method unregister the socket from the given poller, close the\n        socket, and then recreate the socket and register this new socket in the\n        poller.\n\n        Args:\n            socket (zmq.Socket): ZMQ socket to reset.\n            context (zmq.Context): ZMQ context to use.\n            poller (zmq.Poller): ZMQ poller where the socket is registered.\n\n        Returns:\n            zmq.Socket: Initialized and connected socket, ready to use.\n        \"\"\"\n        # Close the existing socket\n        poller.unregister(socket)\n        socket.close(linger=0)\n\n        # Recreate the socket\n        socket = self.create_socket(context)\n        poller.register(socket, zmq.POLLIN)\n\n        return socket\n\n    def ping(self, socket: zmq.Socket):\n        \"\"\"Helper method used for the heartbeat. Also takes care of keeping the\n        counter of heartbeats up-to-date.\n\n        Args:\n            socket (zmq.Socket): Socket to use to send the heartbeat.\n        \"\"\"\n        logger.debug(\"Sending ping...\")\n        socket.send(PING)\n        self.waiting_pong += 1\n\n    def run(self):\n        \"\"\"Main method. It will initialize the worker class, and enter an\n        infinite loop, waiting for requests. Whenever a request is received, it\n        processes it with the code provided in the constructor.\n        \"\"\"\n        # Instanciate the worker\n        worker = self.worker_cls(*self.worker_args, **self.worker_kwargs)\n\n        # Initialize what we need for handling sockets\n        context = zmq.Context()\n        poller = zmq.Poller()\n\n        # Create the socket for termination\n        term_socket = self.create_term_socket(context)\n        poller.register(term_socket, zmq.POLLIN)\n\n        # Create the socket connecting to the hub\n        socket = self.create_socket(context)\n        poller.register(socket, zmq.POLLIN)\n\n        logger.info(\"Worker ready to roll\")\n\n        # Tell the Hub we are ready\n        self.ping(socket)\n\n        # Indefinitely wait for requests : when we are done with one request,\n        # we wait for the next one\n        while True:\n            logger.debug(\"Waiting for request...\")\n            events = dict(poller.poll(self.heartbeat_t * MS))\n\n            if term_socket in events:\n                logger.debug(\"Termination signal received, shutting down gracefully\")\n                break\n\n            if socket in events:\n                _, workload = socket.recv_multipart(zmq.NOBLOCK)\n                logger.debug(\"Received something !\")\n                self.waiting_pong = 0\n            else:\n                logger.debug(f\"Didn't receive anything for {self.heartbeat_t}s ({self.waiting_pong})\")\n\n                if self.waiting_pong &gt;= self.reset_n_miss:\n                    logger.warning(\n                        f\"The Hub is not answering, even after {self.waiting_pong} missed pings... \"\n                        f\"Resetting the socket\"\n                    )\n                    socket = self.reset_socket(socket=socket, context=context, poller=poller)\n                    self.waiting_pong = 0\n\n                # We didn't receive anything for some time, try to ping again\n                self.ping(socket)\n                continue\n\n            if workload == PONG:\n                # Just a Pong, ignore it\n                logger.debug(\"It was just a pong...\")\n                continue\n\n            # From here the Hub sent us an actual request\n            req_id, req_args, req_kwargs = msgpack.unpackb(workload)\n            logger.debug(f\"Request #{req_id} received\")\n\n            # Call worker's code with the request arguments\n            try:\n                res = worker(*req_args, **req_kwargs)\n            except Exception as e:\n                logger.warning(f\"Exception in user-defined __call__ method : {e.__class__.__name__}({str(e)})\")\n                socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_FAILURE, traceback.format_exc()])])\n            else:\n                logger.debug(\"Sending back the response\")\n                socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_SUCCESS, res])])\n\n        logger.info(\"Worker is shut down\")\n        quit()\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.create_socket","title":"<code>create_socket(context)</code>","text":"<p>Helper method to create a socket, setting its identity and connecting to the Hub.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>ZMQ context to use.</p> required <p>Returns:</p> Type Description <code>Socket</code> <p>zmq.Socket: Initialized and connected socket, ready to use.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def create_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n    \"\"\"Helper method to create a socket, setting its identity and connecting\n    to the Hub.\n\n    Args:\n        context (zmq.Context): ZMQ context to use.\n\n    Returns:\n        zmq.Socket: Initialized and connected socket, ready to use.\n    \"\"\"\n    # Create the socket, set its identity\n    socket = context.socket(zmq.DEALER)\n    socket.setsockopt_string(zmq.IDENTITY, self.identity)\n\n    # Connect to the Hub\n    socket.connect(f\"tcp://{self.host}:{self.port}\")\n\n    return socket\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.create_term_socket","title":"<code>create_term_socket(context)</code>","text":"<p>Helper method to create a termination socket.</p> <p>Basically it creates 2 sockets, bind/connect them together. One socket will be used to send a termination signal, and the other is returned and used to receive the termination signal.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>ZMQ context to use.</p> required <p>Returns:</p> Type Description <code>Socket</code> <p>zmq.Socket: Initialized and connected socket, ready to use.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def create_term_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n    \"\"\"Helper method to create a termination socket.\n\n    Basically it creates 2 sockets, bind/connect them together. One socket\n    will be used to send a termination signal, and the other is returned and\n    used to receive the termination signal.\n\n    Args:\n        context (zmq.Context): ZMQ context to use.\n\n    Returns:\n        zmq.Socket: Initialized and connected socket, ready to use.\n    \"\"\"\n    # Create the socket than will send the termination ping\n    term_snd_socket = context.socket(zmq.REQ)\n    port = term_snd_socket.bind_to_random_port(\"tcp://127.0.0.1\")\n\n    # Then define the behavior on how to send the termination ping\n    def send_term(*args, **kwargs):\n        logger.debug(\"Sending termination ping...\")\n        # Send something on the termination socket, it doesn't matter what\n        term_snd_socket.send(PING)\n\n    # We send the termination ping upon receiving these signals\n    signal.signal(signal.SIGTERM, send_term)\n    signal.signal(signal.SIGINT, send_term)\n\n    # And finally create the socket that we will use to receive the termination signal\n    term_rcv_socket = context.socket(zmq.REP)\n    term_rcv_socket.connect(f\"tcp://localhost:{port}\")\n\n    return term_rcv_socket\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.ping","title":"<code>ping(socket)</code>","text":"<p>Helper method used for the heartbeat. Also takes care of keeping the counter of heartbeats up-to-date.</p> <p>Parameters:</p> Name Type Description Default <code>socket</code> <code>Socket</code> <p>Socket to use to send the heartbeat.</p> required Source code in <code>gibbs/worker.py</code> <pre><code>def ping(self, socket: zmq.Socket):\n    \"\"\"Helper method used for the heartbeat. Also takes care of keeping the\n    counter of heartbeats up-to-date.\n\n    Args:\n        socket (zmq.Socket): Socket to use to send the heartbeat.\n    \"\"\"\n    logger.debug(\"Sending ping...\")\n    socket.send(PING)\n    self.waiting_pong += 1\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.reset_socket","title":"<code>reset_socket(socket, context, poller)</code>","text":"<p>Helper method to reset the given socket.</p> <p>This method unregister the socket from the given poller, close the socket, and then recreate the socket and register this new socket in the poller.</p> <p>Parameters:</p> Name Type Description Default <code>socket</code> <code>Socket</code> <p>ZMQ socket to reset.</p> required <code>context</code> <code>Context</code> <p>ZMQ context to use.</p> required <code>poller</code> <code>Poller</code> <p>ZMQ poller where the socket is registered.</p> required <p>Returns:</p> Type Description <code>Socket</code> <p>zmq.Socket: Initialized and connected socket, ready to use.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def reset_socket(self, socket: zmq.Socket, context: zmq.Context, poller: zmq.Poller) -&gt; zmq.Socket:\n    \"\"\"Helper method to reset the given socket.\n\n    This method unregister the socket from the given poller, close the\n    socket, and then recreate the socket and register this new socket in the\n    poller.\n\n    Args:\n        socket (zmq.Socket): ZMQ socket to reset.\n        context (zmq.Context): ZMQ context to use.\n        poller (zmq.Poller): ZMQ poller where the socket is registered.\n\n    Returns:\n        zmq.Socket: Initialized and connected socket, ready to use.\n    \"\"\"\n    # Close the existing socket\n    poller.unregister(socket)\n    socket.close(linger=0)\n\n    # Recreate the socket\n    socket = self.create_socket(context)\n    poller.register(socket, zmq.POLLIN)\n\n    return socket\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.run","title":"<code>run()</code>","text":"<p>Main method. It will initialize the worker class, and enter an infinite loop, waiting for requests. Whenever a request is received, it processes it with the code provided in the constructor.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def run(self):\n    \"\"\"Main method. It will initialize the worker class, and enter an\n    infinite loop, waiting for requests. Whenever a request is received, it\n    processes it with the code provided in the constructor.\n    \"\"\"\n    # Instanciate the worker\n    worker = self.worker_cls(*self.worker_args, **self.worker_kwargs)\n\n    # Initialize what we need for handling sockets\n    context = zmq.Context()\n    poller = zmq.Poller()\n\n    # Create the socket for termination\n    term_socket = self.create_term_socket(context)\n    poller.register(term_socket, zmq.POLLIN)\n\n    # Create the socket connecting to the hub\n    socket = self.create_socket(context)\n    poller.register(socket, zmq.POLLIN)\n\n    logger.info(\"Worker ready to roll\")\n\n    # Tell the Hub we are ready\n    self.ping(socket)\n\n    # Indefinitely wait for requests : when we are done with one request,\n    # we wait for the next one\n    while True:\n        logger.debug(\"Waiting for request...\")\n        events = dict(poller.poll(self.heartbeat_t * MS))\n\n        if term_socket in events:\n            logger.debug(\"Termination signal received, shutting down gracefully\")\n            break\n\n        if socket in events:\n            _, workload = socket.recv_multipart(zmq.NOBLOCK)\n            logger.debug(\"Received something !\")\n            self.waiting_pong = 0\n        else:\n            logger.debug(f\"Didn't receive anything for {self.heartbeat_t}s ({self.waiting_pong})\")\n\n            if self.waiting_pong &gt;= self.reset_n_miss:\n                logger.warning(\n                    f\"The Hub is not answering, even after {self.waiting_pong} missed pings... \"\n                    f\"Resetting the socket\"\n                )\n                socket = self.reset_socket(socket=socket, context=context, poller=poller)\n                self.waiting_pong = 0\n\n            # We didn't receive anything for some time, try to ping again\n            self.ping(socket)\n            continue\n\n        if workload == PONG:\n            # Just a Pong, ignore it\n            logger.debug(\"It was just a pong...\")\n            continue\n\n        # From here the Hub sent us an actual request\n        req_id, req_args, req_kwargs = msgpack.unpackb(workload)\n        logger.debug(f\"Request #{req_id} received\")\n\n        # Call worker's code with the request arguments\n        try:\n            res = worker(*req_args, **req_kwargs)\n        except Exception as e:\n            logger.warning(f\"Exception in user-defined __call__ method : {e.__class__.__name__}({str(e)})\")\n            socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_FAILURE, traceback.format_exc()])])\n        else:\n            logger.debug(\"Sending back the response\")\n            socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_SUCCESS, res])])\n\n    logger.info(\"Worker is shut down\")\n    quit()\n</code></pre>"},{"location":"code_ref/#internal","title":"Internal","text":""},{"location":"code_ref/#gibbs.hub.Hub","title":"<code>Hub</code>","text":"<p>Class acting as a hub for all the requests to send. All requests sent through this class will be automatically dispatched to connected workers, will wait for the responses and return it.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port number to use for the sockets. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>heartbeat_interval</code> <code>float</code> <p>Heartbeat interval used by the workers, in seconds. Defaults to DEFAULT_HEARTBEAT_INTERVAL.</p> <code>DEFAULT_HEARTBEAT_INTERVAL</code> <code>resp_buffer_size</code> <code>int</code> <p>Maximum response buffer size. Defaults to RESPONSE_BUFFER_SIZE.</p> <code>RESPONSE_BUFFER_SIZE</code> Source code in <code>gibbs/hub.py</code> <pre><code>class Hub:\n    \"\"\"Class acting as a hub for all the requests to send. All requests sent\n    through this class will be automatically dispatched to connected workers,\n    will wait for the responses and return it.\n\n    Args:\n        port (int): Port number to use for the sockets. Defaults to\n            DEFAULT_PORT.\n        heartbeat_interval (float): Heartbeat interval used by the\n            workers, in seconds. Defaults to DEFAULT_HEARTBEAT_INTERVAL.\n        resp_buffer_size (int): Maximum response buffer size. Defaults\n            to RESPONSE_BUFFER_SIZE.\n    \"\"\"\n\n    def __init__(\n        self,\n        port: int = DEFAULT_PORT,\n        heartbeat_interval: float = DEFAULT_HEARTBEAT_INTERVAL,\n        resp_buffer_size: int = RESPONSE_BUFFER_SIZE,\n    ):\n        super().__init__()\n\n        self.port = port\n        self.heartbeat_t = heartbeat_interval\n        self.socket = None\n        self.w_manager = None\n        self.req_manager = RequestManager(resp_buffer_size=resp_buffer_size)\n\n    async def receive_loop(self):\n        \"\"\"Infinite loop for receiving responses from the workers.\"\"\"\n        while True:\n            # Receive stuff\n            logger.debug(\"Receiving...\")\n            address, *frames = await self.socket.recv_multipart()\n            logger.debug(f\"Received something from worker #{address}\")\n\n            # Since we received a response from this worker, it means it's ready for more !\n            await self.w_manager.reckon(address)\n\n            if len(frames) == 1:\n                # Answer the Ping\n                logger.debug(\"Answering the ping\")\n                await self.socket.send_multipart([address, b\"\", PONG])\n                continue\n\n            _, resp = frames\n            req_id, code, res = msgpack.unpackb(resp)\n            logger.debug(f\"Received response from request #{req_id}\")\n\n            self.req_manager.store(req_id, code, res)\n\n    def _start_if_not_started(self):\n        \"\"\"Helper method to ensure everything is properly started (socket is\n        initialized, receiving loop is started, etc...).\n        \"\"\"\n        if self.socket is None:\n            # Create what we need here in this process/context\n            context = zmq.asyncio.Context()\n            self.socket = context.socket(zmq.ROUTER)\n            self.socket.bind(f\"tcp://*:{self.port}\")\n            self.w_manager = WorkerManager(heartbeat_interval=self.heartbeat_t)\n\n            # Fire and forget : infinite loop, taking care of receiving stuff from the socket\n            logger.info(\"Starting receiving loop...\")\n            asyncio.create_task(self.receive_loop())\n\n    async def _request(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Raw method to send a request. This method will do the following :\n         * Start the receiving loop if it was not started\n         * Get the address of the next worker ready (blocking)\n         * Send the request to the worker\n         * Wait for the response (blocking)\n         * Return the result\n\n        Args:\n            *args: Positional arguments for the request.\n            **kwargs: Keywords arguments for the request.\n\n        Raises:\n            UserCodeException: Exception raised if an exception was raised inside\n                user-defined code on the worker side.\n\n        Returns:\n            Any: The response for the request.\n        \"\"\"\n        # Before anything, if the receiving loop was not started, start it\n        self._start_if_not_started()\n\n        # Assign a unique ID to the request\n        req_id = uuid.uuid4().hex\n\n        # Let the manager know that we are waiting for this request\n        logger.debug(f\"Pinning request #{req_id}\")\n        self.req_manager.pin(req_id)\n\n        # Send the request\n        address = await self.w_manager.get_next_worker()\n        logger.debug(f\"Sending request #{req_id} to worker #{address}\")\n        await self.socket.send_multipart([address, b\"\", msgpack.packb([req_id, args, kwargs])])\n\n        # Wait until we receive the response\n        code, res = await self.req_manager.wait_for(req_id)\n        logger.debug(f\"Received result for request #{req_id}\")\n\n        # Depending on what is the response, deal with it properly\n        if code == CODE_FAILURE:\n            raise UserCodeException(res)\n        else:\n            return res\n\n    async def request(self, *args: Any, gibbs_timeout: float = None, gibbs_retries: int = 0, **kwargs: Any) -&gt; Any:\n        \"\"\"Main method, used to send a request to workers and get the result.\n\n        This method is a wrapper around `_request`, providing additional\n        functionalities :\n         * Timeout\n         * Automatic retries\n\n        Args:\n            *args: Positional arguments for the request.\n            gibbs_timeout (float): Timeout for the request, in seconds.\n                If `None` is given, block until the request is complete.\n                Defaults to None.\n            gibbs_retries (int): Number of retries. This argument is\n                used only if `gibbs_timeout` is not `None`. If `-1` is given,\n                indefinitely retry. Defaults to 0.\n            **kwargs: Keywords arguments for the request.\n\n        Raises:\n            asyncio.TimeoutError: Error raised if no response is received within\n                the given timeout.\n\n        Returns:\n            Any: The response for the request.\n        \"\"\"\n        try:\n            return await asyncio.wait_for(self._request(*args, **kwargs), timeout=gibbs_timeout)\n        except asyncio.TimeoutError:\n            if gibbs_retries == 0:\n                logger.error(f\"Request failed : no response received within {gibbs_timeout}s\")\n                raise\n            else:\n                retries_left = max(gibbs_retries - 1, -1)\n                logger.warning(\n                    f\"Request failed : no response received within {gibbs_timeout}s. Retrying {retries_left} times\"\n                )\n                return await self.request(*args, gibbs_timeout=gibbs_timeout, gibbs_retries=retries_left, **kwargs)\n\n    def __del__(self):\n        if self.socket is not None:\n            self.socket.close()\n</code></pre>"},{"location":"code_ref/#gibbs.hub.Hub.receive_loop","title":"<code>receive_loop()</code>  <code>async</code>","text":"<p>Infinite loop for receiving responses from the workers.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def receive_loop(self):\n    \"\"\"Infinite loop for receiving responses from the workers.\"\"\"\n    while True:\n        # Receive stuff\n        logger.debug(\"Receiving...\")\n        address, *frames = await self.socket.recv_multipart()\n        logger.debug(f\"Received something from worker #{address}\")\n\n        # Since we received a response from this worker, it means it's ready for more !\n        await self.w_manager.reckon(address)\n\n        if len(frames) == 1:\n            # Answer the Ping\n            logger.debug(\"Answering the ping\")\n            await self.socket.send_multipart([address, b\"\", PONG])\n            continue\n\n        _, resp = frames\n        req_id, code, res = msgpack.unpackb(resp)\n        logger.debug(f\"Received response from request #{req_id}\")\n\n        self.req_manager.store(req_id, code, res)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.Hub.request","title":"<code>request(*args, gibbs_timeout=None, gibbs_retries=0, **kwargs)</code>  <code>async</code>","text":"<p>Main method, used to send a request to workers and get the result.</p> <p>This method is a wrapper around <code>_request</code>, providing additional functionalities :  * Timeout  * Automatic retries</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments for the request.</p> <code>()</code> <code>gibbs_timeout</code> <code>float</code> <p>Timeout for the request, in seconds. If <code>None</code> is given, block until the request is complete. Defaults to None.</p> <code>None</code> <code>gibbs_retries</code> <code>int</code> <p>Number of retries. This argument is used only if <code>gibbs_timeout</code> is not <code>None</code>. If <code>-1</code> is given, indefinitely retry. Defaults to 0.</p> <code>0</code> <code>**kwargs</code> <code>Any</code> <p>Keywords arguments for the request.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>Error raised if no response is received within the given timeout.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response for the request.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def request(self, *args: Any, gibbs_timeout: float = None, gibbs_retries: int = 0, **kwargs: Any) -&gt; Any:\n    \"\"\"Main method, used to send a request to workers and get the result.\n\n    This method is a wrapper around `_request`, providing additional\n    functionalities :\n     * Timeout\n     * Automatic retries\n\n    Args:\n        *args: Positional arguments for the request.\n        gibbs_timeout (float): Timeout for the request, in seconds.\n            If `None` is given, block until the request is complete.\n            Defaults to None.\n        gibbs_retries (int): Number of retries. This argument is\n            used only if `gibbs_timeout` is not `None`. If `-1` is given,\n            indefinitely retry. Defaults to 0.\n        **kwargs: Keywords arguments for the request.\n\n    Raises:\n        asyncio.TimeoutError: Error raised if no response is received within\n            the given timeout.\n\n    Returns:\n        Any: The response for the request.\n    \"\"\"\n    try:\n        return await asyncio.wait_for(self._request(*args, **kwargs), timeout=gibbs_timeout)\n    except asyncio.TimeoutError:\n        if gibbs_retries == 0:\n            logger.error(f\"Request failed : no response received within {gibbs_timeout}s\")\n            raise\n        else:\n            retries_left = max(gibbs_retries - 1, -1)\n            logger.warning(\n                f\"Request failed : no response received within {gibbs_timeout}s. Retrying {retries_left} times\"\n            )\n            return await self.request(*args, gibbs_timeout=gibbs_timeout, gibbs_retries=retries_left, **kwargs)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager","title":"<code>RequestManager</code>","text":"<p>A helper class that takes care of storing responses and waiting for the right response.</p> <p>Parameters:</p> Name Type Description Default <code>resp_buffer_size</code> <code>int</code> <p>Maximum size of the response buffer.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class RequestManager:\n    \"\"\"A helper class that takes care of storing responses and waiting for the\n    right response.\n\n    Args:\n        resp_buffer_size (int): Maximum size of the response buffer.\n    \"\"\"\n\n    def __init__(self, resp_buffer_size: int):\n        super().__init__()\n\n        self.resp_buffer_size = resp_buffer_size\n\n        self.responses = {}\n        self.req_states = {}\n\n    def pin(self, req_id: str):\n        \"\"\"Pin a request ID. This is a necessary step when sending a request,\n        so that the request can be awaited until a response is received.\n        This method should be called for each `req_id` before calling `wait_for`.\n\n        Args:\n            req_id (str): Request unique identifier.\n        \"\"\"\n        self.req_states[req_id] = asyncio.Event()\n\n        # Ensure we don't store too many requests\n        if len(self.req_states) &gt; self.resp_buffer_size:\n            # If it's the case, forget the oldest one\n            k = list(self.req_states.keys())[0]\n            logger.warning(f\"Response buffer overflow (&gt;{self.resp_buffer_size}). Forgetting oldest request : {k}\")\n            self.req_states.pop(k)\n            self.responses.pop(k, None)\n\n    async def wait_for(self, req_id: str) -&gt; Tuple[int, Any]:\n        \"\"\"Async method that waits until we received the response corresponding\n        to the given request ID.\n\n        The method `pin` should be called before waiting with this method.\n\n        Args:\n            req_id (str): Request unique identifier.\n\n        Raises:\n            KeyError: Exception raised if the request wasn't registered previously.\n\n        Returns:\n            Tuple[int, Any]: Code and content of the received response.\n        \"\"\"\n        if req_id not in self.req_states:\n            raise KeyError(f\"Request #{req_id} was not pinned, or was removed because of buffer overflow\")\n\n        # Wait for the receiving loop to receive the response\n        await self.req_states[req_id].wait()\n\n        # Once we get it, access the result\n        r = self.responses.pop(req_id)\n\n        # Don't forget to remove the event\n        self.req_states.pop(req_id)\n\n        return r.code, r.content\n\n    def store(self, req_id: str, code: int, response: Any):\n        \"\"\"Store a response, to be consumed later.\n\n        Args:\n            req_id (str): Request unique identifier.\n            code (int): Code of the response.\n            response (Any): Content of the response.\n        \"\"\"\n        # Store the response if the req_id is recognized\n        if req_id in self.req_states:\n            self.responses[req_id] = Response(code, response)\n\n            # Notify that we received the response\n            self.req_states[req_id].set()\n        else:\n            logger.warning(\n                f\"Request #{req_id} was previously removed from response buffer. \"\n                f\"Ignoring the response from this request...\"\n            )\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.pin","title":"<code>pin(req_id)</code>","text":"<p>Pin a request ID. This is a necessary step when sending a request, so that the request can be awaited until a response is received. This method should be called for each <code>req_id</code> before calling <code>wait_for</code>.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>def pin(self, req_id: str):\n    \"\"\"Pin a request ID. This is a necessary step when sending a request,\n    so that the request can be awaited until a response is received.\n    This method should be called for each `req_id` before calling `wait_for`.\n\n    Args:\n        req_id (str): Request unique identifier.\n    \"\"\"\n    self.req_states[req_id] = asyncio.Event()\n\n    # Ensure we don't store too many requests\n    if len(self.req_states) &gt; self.resp_buffer_size:\n        # If it's the case, forget the oldest one\n        k = list(self.req_states.keys())[0]\n        logger.warning(f\"Response buffer overflow (&gt;{self.resp_buffer_size}). Forgetting oldest request : {k}\")\n        self.req_states.pop(k)\n        self.responses.pop(k, None)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.store","title":"<code>store(req_id, code, response)</code>","text":"<p>Store a response, to be consumed later.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required <code>code</code> <code>int</code> <p>Code of the response.</p> required <code>response</code> <code>Any</code> <p>Content of the response.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>def store(self, req_id: str, code: int, response: Any):\n    \"\"\"Store a response, to be consumed later.\n\n    Args:\n        req_id (str): Request unique identifier.\n        code (int): Code of the response.\n        response (Any): Content of the response.\n    \"\"\"\n    # Store the response if the req_id is recognized\n    if req_id in self.req_states:\n        self.responses[req_id] = Response(code, response)\n\n        # Notify that we received the response\n        self.req_states[req_id].set()\n    else:\n        logger.warning(\n            f\"Request #{req_id} was previously removed from response buffer. \"\n            f\"Ignoring the response from this request...\"\n        )\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.wait_for","title":"<code>wait_for(req_id)</code>  <code>async</code>","text":"<p>Async method that waits until we received the response corresponding to the given request ID.</p> <p>The method <code>pin</code> should be called before waiting with this method.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>Exception raised if the request wasn't registered previously.</p> <p>Returns:</p> Type Description <code>Tuple[int, Any]</code> <p>Tuple[int, Any]: Code and content of the received response.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def wait_for(self, req_id: str) -&gt; Tuple[int, Any]:\n    \"\"\"Async method that waits until we received the response corresponding\n    to the given request ID.\n\n    The method `pin` should be called before waiting with this method.\n\n    Args:\n        req_id (str): Request unique identifier.\n\n    Raises:\n        KeyError: Exception raised if the request wasn't registered previously.\n\n    Returns:\n        Tuple[int, Any]: Code and content of the received response.\n    \"\"\"\n    if req_id not in self.req_states:\n        raise KeyError(f\"Request #{req_id} was not pinned, or was removed because of buffer overflow\")\n\n    # Wait for the receiving loop to receive the response\n    await self.req_states[req_id].wait()\n\n    # Once we get it, access the result\n    r = self.responses.pop(req_id)\n\n    # Don't forget to remove the event\n    self.req_states.pop(req_id)\n\n    return r.code, r.content\n</code></pre>"},{"location":"code_ref/#gibbs.hub.UserCodeException","title":"<code>UserCodeException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom Exception for user-defined catched errors.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>Traceback returned by the worker.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class UserCodeException(Exception):\n    \"\"\"Custom Exception for user-defined catched errors.\n\n    Args:\n        t (str): Traceback returned by the worker.\n    \"\"\"\n\n    def __init__(self, t: str):\n        super().__init__(f\"Exception raised in user-defined code. Traceback :\\n{t}\")\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager","title":"<code>WorkerManager</code>","text":"<p>A helper class that takes care of managing workers. Workers' address can be registered as available, and this class will make sure to return address of workers that are available and alive.</p> <p>A worker is considered as dead if we didn't receive any heartbeat within a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>heartbeat_interval</code> <code>float</code> <p>Interval of time (in seconds) after which we consider a worker to be dead.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class WorkerManager:\n    \"\"\"A helper class that takes care of managing workers.\n    Workers' address can be registered as available, and this class will make\n    sure to return address of workers that are available and alive.\n\n    A worker is considered as dead if we didn't receive any heartbeat within a\n    given interval.\n\n    Args:\n        heartbeat_interval (float): Interval of time (in seconds) after which we\n            consider a worker to be dead.\n    \"\"\"\n\n    def __init__(self, heartbeat_interval: float):\n        super().__init__()\n\n        self.heartbeat_t = heartbeat_interval\n\n        self.w_ts = {}\n        self.w_access = asyncio.Condition()\n\n    async def reckon(self, address: str):\n        \"\"\"Register the given address as available.\n\n        Args:\n            address (str): Address of the worker to register as available.\n        \"\"\"\n        async with self.w_access:\n            self.w_ts[address] = time.time()\n            self.w_access.notify()\n\n    async def get_next_worker(self) -&gt; str:\n        \"\"\"Retrieve the next available and alive worker's address.\n\n        Returns:\n            str: Address of the available and alive worker.\n        \"\"\"\n        async with self.w_access:\n            # Iterate workers until we find one that was alive recently\n            w_alive = False\n            while not w_alive:\n                # If no workers are available, wait...\n                if not self.w_ts:\n                    await self.w_access.wait()\n\n                address, ts = self.w_ts.popitem()\n                w_alive = time.time() - ts &lt; self.heartbeat_t\n\n            return address\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager.get_next_worker","title":"<code>get_next_worker()</code>  <code>async</code>","text":"<p>Retrieve the next available and alive worker's address.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Address of the available and alive worker.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def get_next_worker(self) -&gt; str:\n    \"\"\"Retrieve the next available and alive worker's address.\n\n    Returns:\n        str: Address of the available and alive worker.\n    \"\"\"\n    async with self.w_access:\n        # Iterate workers until we find one that was alive recently\n        w_alive = False\n        while not w_alive:\n            # If no workers are available, wait...\n            if not self.w_ts:\n                await self.w_access.wait()\n\n            address, ts = self.w_ts.popitem()\n            w_alive = time.time() - ts &lt; self.heartbeat_t\n\n        return address\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager.reckon","title":"<code>reckon(address)</code>  <code>async</code>","text":"<p>Register the given address as available.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address of the worker to register as available.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>async def reckon(self, address: str):\n    \"\"\"Register the given address as available.\n\n    Args:\n        address (str): Address of the worker to register as available.\n    \"\"\"\n    async with self.w_access:\n        self.w_ts[address] = time.time()\n        self.w_access.notify()\n</code></pre>"},{"location":"code_ref/#constants","title":"Constants","text":""},{"location":"code_ref/#gibbs.hub.Hub","title":"<code>Hub</code>","text":"<p>Class acting as a hub for all the requests to send. All requests sent through this class will be automatically dispatched to connected workers, will wait for the responses and return it.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port number to use for the sockets. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>heartbeat_interval</code> <code>float</code> <p>Heartbeat interval used by the workers, in seconds. Defaults to DEFAULT_HEARTBEAT_INTERVAL.</p> <code>DEFAULT_HEARTBEAT_INTERVAL</code> <code>resp_buffer_size</code> <code>int</code> <p>Maximum response buffer size. Defaults to RESPONSE_BUFFER_SIZE.</p> <code>RESPONSE_BUFFER_SIZE</code> Source code in <code>gibbs/hub.py</code> <pre><code>class Hub:\n    \"\"\"Class acting as a hub for all the requests to send. All requests sent\n    through this class will be automatically dispatched to connected workers,\n    will wait for the responses and return it.\n\n    Args:\n        port (int): Port number to use for the sockets. Defaults to\n            DEFAULT_PORT.\n        heartbeat_interval (float): Heartbeat interval used by the\n            workers, in seconds. Defaults to DEFAULT_HEARTBEAT_INTERVAL.\n        resp_buffer_size (int): Maximum response buffer size. Defaults\n            to RESPONSE_BUFFER_SIZE.\n    \"\"\"\n\n    def __init__(\n        self,\n        port: int = DEFAULT_PORT,\n        heartbeat_interval: float = DEFAULT_HEARTBEAT_INTERVAL,\n        resp_buffer_size: int = RESPONSE_BUFFER_SIZE,\n    ):\n        super().__init__()\n\n        self.port = port\n        self.heartbeat_t = heartbeat_interval\n        self.socket = None\n        self.w_manager = None\n        self.req_manager = RequestManager(resp_buffer_size=resp_buffer_size)\n\n    async def receive_loop(self):\n        \"\"\"Infinite loop for receiving responses from the workers.\"\"\"\n        while True:\n            # Receive stuff\n            logger.debug(\"Receiving...\")\n            address, *frames = await self.socket.recv_multipart()\n            logger.debug(f\"Received something from worker #{address}\")\n\n            # Since we received a response from this worker, it means it's ready for more !\n            await self.w_manager.reckon(address)\n\n            if len(frames) == 1:\n                # Answer the Ping\n                logger.debug(\"Answering the ping\")\n                await self.socket.send_multipart([address, b\"\", PONG])\n                continue\n\n            _, resp = frames\n            req_id, code, res = msgpack.unpackb(resp)\n            logger.debug(f\"Received response from request #{req_id}\")\n\n            self.req_manager.store(req_id, code, res)\n\n    def _start_if_not_started(self):\n        \"\"\"Helper method to ensure everything is properly started (socket is\n        initialized, receiving loop is started, etc...).\n        \"\"\"\n        if self.socket is None:\n            # Create what we need here in this process/context\n            context = zmq.asyncio.Context()\n            self.socket = context.socket(zmq.ROUTER)\n            self.socket.bind(f\"tcp://*:{self.port}\")\n            self.w_manager = WorkerManager(heartbeat_interval=self.heartbeat_t)\n\n            # Fire and forget : infinite loop, taking care of receiving stuff from the socket\n            logger.info(\"Starting receiving loop...\")\n            asyncio.create_task(self.receive_loop())\n\n    async def _request(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Raw method to send a request. This method will do the following :\n         * Start the receiving loop if it was not started\n         * Get the address of the next worker ready (blocking)\n         * Send the request to the worker\n         * Wait for the response (blocking)\n         * Return the result\n\n        Args:\n            *args: Positional arguments for the request.\n            **kwargs: Keywords arguments for the request.\n\n        Raises:\n            UserCodeException: Exception raised if an exception was raised inside\n                user-defined code on the worker side.\n\n        Returns:\n            Any: The response for the request.\n        \"\"\"\n        # Before anything, if the receiving loop was not started, start it\n        self._start_if_not_started()\n\n        # Assign a unique ID to the request\n        req_id = uuid.uuid4().hex\n\n        # Let the manager know that we are waiting for this request\n        logger.debug(f\"Pinning request #{req_id}\")\n        self.req_manager.pin(req_id)\n\n        # Send the request\n        address = await self.w_manager.get_next_worker()\n        logger.debug(f\"Sending request #{req_id} to worker #{address}\")\n        await self.socket.send_multipart([address, b\"\", msgpack.packb([req_id, args, kwargs])])\n\n        # Wait until we receive the response\n        code, res = await self.req_manager.wait_for(req_id)\n        logger.debug(f\"Received result for request #{req_id}\")\n\n        # Depending on what is the response, deal with it properly\n        if code == CODE_FAILURE:\n            raise UserCodeException(res)\n        else:\n            return res\n\n    async def request(self, *args: Any, gibbs_timeout: float = None, gibbs_retries: int = 0, **kwargs: Any) -&gt; Any:\n        \"\"\"Main method, used to send a request to workers and get the result.\n\n        This method is a wrapper around `_request`, providing additional\n        functionalities :\n         * Timeout\n         * Automatic retries\n\n        Args:\n            *args: Positional arguments for the request.\n            gibbs_timeout (float): Timeout for the request, in seconds.\n                If `None` is given, block until the request is complete.\n                Defaults to None.\n            gibbs_retries (int): Number of retries. This argument is\n                used only if `gibbs_timeout` is not `None`. If `-1` is given,\n                indefinitely retry. Defaults to 0.\n            **kwargs: Keywords arguments for the request.\n\n        Raises:\n            asyncio.TimeoutError: Error raised if no response is received within\n                the given timeout.\n\n        Returns:\n            Any: The response for the request.\n        \"\"\"\n        try:\n            return await asyncio.wait_for(self._request(*args, **kwargs), timeout=gibbs_timeout)\n        except asyncio.TimeoutError:\n            if gibbs_retries == 0:\n                logger.error(f\"Request failed : no response received within {gibbs_timeout}s\")\n                raise\n            else:\n                retries_left = max(gibbs_retries - 1, -1)\n                logger.warning(\n                    f\"Request failed : no response received within {gibbs_timeout}s. Retrying {retries_left} times\"\n                )\n                return await self.request(*args, gibbs_timeout=gibbs_timeout, gibbs_retries=retries_left, **kwargs)\n\n    def __del__(self):\n        if self.socket is not None:\n            self.socket.close()\n</code></pre>"},{"location":"code_ref/#gibbs.hub.Hub.receive_loop","title":"<code>receive_loop()</code>  <code>async</code>","text":"<p>Infinite loop for receiving responses from the workers.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def receive_loop(self):\n    \"\"\"Infinite loop for receiving responses from the workers.\"\"\"\n    while True:\n        # Receive stuff\n        logger.debug(\"Receiving...\")\n        address, *frames = await self.socket.recv_multipart()\n        logger.debug(f\"Received something from worker #{address}\")\n\n        # Since we received a response from this worker, it means it's ready for more !\n        await self.w_manager.reckon(address)\n\n        if len(frames) == 1:\n            # Answer the Ping\n            logger.debug(\"Answering the ping\")\n            await self.socket.send_multipart([address, b\"\", PONG])\n            continue\n\n        _, resp = frames\n        req_id, code, res = msgpack.unpackb(resp)\n        logger.debug(f\"Received response from request #{req_id}\")\n\n        self.req_manager.store(req_id, code, res)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.Hub.request","title":"<code>request(*args, gibbs_timeout=None, gibbs_retries=0, **kwargs)</code>  <code>async</code>","text":"<p>Main method, used to send a request to workers and get the result.</p> <p>This method is a wrapper around <code>_request</code>, providing additional functionalities :  * Timeout  * Automatic retries</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments for the request.</p> <code>()</code> <code>gibbs_timeout</code> <code>float</code> <p>Timeout for the request, in seconds. If <code>None</code> is given, block until the request is complete. Defaults to None.</p> <code>None</code> <code>gibbs_retries</code> <code>int</code> <p>Number of retries. This argument is used only if <code>gibbs_timeout</code> is not <code>None</code>. If <code>-1</code> is given, indefinitely retry. Defaults to 0.</p> <code>0</code> <code>**kwargs</code> <code>Any</code> <p>Keywords arguments for the request.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>Error raised if no response is received within the given timeout.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response for the request.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def request(self, *args: Any, gibbs_timeout: float = None, gibbs_retries: int = 0, **kwargs: Any) -&gt; Any:\n    \"\"\"Main method, used to send a request to workers and get the result.\n\n    This method is a wrapper around `_request`, providing additional\n    functionalities :\n     * Timeout\n     * Automatic retries\n\n    Args:\n        *args: Positional arguments for the request.\n        gibbs_timeout (float): Timeout for the request, in seconds.\n            If `None` is given, block until the request is complete.\n            Defaults to None.\n        gibbs_retries (int): Number of retries. This argument is\n            used only if `gibbs_timeout` is not `None`. If `-1` is given,\n            indefinitely retry. Defaults to 0.\n        **kwargs: Keywords arguments for the request.\n\n    Raises:\n        asyncio.TimeoutError: Error raised if no response is received within\n            the given timeout.\n\n    Returns:\n        Any: The response for the request.\n    \"\"\"\n    try:\n        return await asyncio.wait_for(self._request(*args, **kwargs), timeout=gibbs_timeout)\n    except asyncio.TimeoutError:\n        if gibbs_retries == 0:\n            logger.error(f\"Request failed : no response received within {gibbs_timeout}s\")\n            raise\n        else:\n            retries_left = max(gibbs_retries - 1, -1)\n            logger.warning(\n                f\"Request failed : no response received within {gibbs_timeout}s. Retrying {retries_left} times\"\n            )\n            return await self.request(*args, gibbs_timeout=gibbs_timeout, gibbs_retries=retries_left, **kwargs)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager","title":"<code>RequestManager</code>","text":"<p>A helper class that takes care of storing responses and waiting for the right response.</p> <p>Parameters:</p> Name Type Description Default <code>resp_buffer_size</code> <code>int</code> <p>Maximum size of the response buffer.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class RequestManager:\n    \"\"\"A helper class that takes care of storing responses and waiting for the\n    right response.\n\n    Args:\n        resp_buffer_size (int): Maximum size of the response buffer.\n    \"\"\"\n\n    def __init__(self, resp_buffer_size: int):\n        super().__init__()\n\n        self.resp_buffer_size = resp_buffer_size\n\n        self.responses = {}\n        self.req_states = {}\n\n    def pin(self, req_id: str):\n        \"\"\"Pin a request ID. This is a necessary step when sending a request,\n        so that the request can be awaited until a response is received.\n        This method should be called for each `req_id` before calling `wait_for`.\n\n        Args:\n            req_id (str): Request unique identifier.\n        \"\"\"\n        self.req_states[req_id] = asyncio.Event()\n\n        # Ensure we don't store too many requests\n        if len(self.req_states) &gt; self.resp_buffer_size:\n            # If it's the case, forget the oldest one\n            k = list(self.req_states.keys())[0]\n            logger.warning(f\"Response buffer overflow (&gt;{self.resp_buffer_size}). Forgetting oldest request : {k}\")\n            self.req_states.pop(k)\n            self.responses.pop(k, None)\n\n    async def wait_for(self, req_id: str) -&gt; Tuple[int, Any]:\n        \"\"\"Async method that waits until we received the response corresponding\n        to the given request ID.\n\n        The method `pin` should be called before waiting with this method.\n\n        Args:\n            req_id (str): Request unique identifier.\n\n        Raises:\n            KeyError: Exception raised if the request wasn't registered previously.\n\n        Returns:\n            Tuple[int, Any]: Code and content of the received response.\n        \"\"\"\n        if req_id not in self.req_states:\n            raise KeyError(f\"Request #{req_id} was not pinned, or was removed because of buffer overflow\")\n\n        # Wait for the receiving loop to receive the response\n        await self.req_states[req_id].wait()\n\n        # Once we get it, access the result\n        r = self.responses.pop(req_id)\n\n        # Don't forget to remove the event\n        self.req_states.pop(req_id)\n\n        return r.code, r.content\n\n    def store(self, req_id: str, code: int, response: Any):\n        \"\"\"Store a response, to be consumed later.\n\n        Args:\n            req_id (str): Request unique identifier.\n            code (int): Code of the response.\n            response (Any): Content of the response.\n        \"\"\"\n        # Store the response if the req_id is recognized\n        if req_id in self.req_states:\n            self.responses[req_id] = Response(code, response)\n\n            # Notify that we received the response\n            self.req_states[req_id].set()\n        else:\n            logger.warning(\n                f\"Request #{req_id} was previously removed from response buffer. \"\n                f\"Ignoring the response from this request...\"\n            )\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.pin","title":"<code>pin(req_id)</code>","text":"<p>Pin a request ID. This is a necessary step when sending a request, so that the request can be awaited until a response is received. This method should be called for each <code>req_id</code> before calling <code>wait_for</code>.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>def pin(self, req_id: str):\n    \"\"\"Pin a request ID. This is a necessary step when sending a request,\n    so that the request can be awaited until a response is received.\n    This method should be called for each `req_id` before calling `wait_for`.\n\n    Args:\n        req_id (str): Request unique identifier.\n    \"\"\"\n    self.req_states[req_id] = asyncio.Event()\n\n    # Ensure we don't store too many requests\n    if len(self.req_states) &gt; self.resp_buffer_size:\n        # If it's the case, forget the oldest one\n        k = list(self.req_states.keys())[0]\n        logger.warning(f\"Response buffer overflow (&gt;{self.resp_buffer_size}). Forgetting oldest request : {k}\")\n        self.req_states.pop(k)\n        self.responses.pop(k, None)\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.store","title":"<code>store(req_id, code, response)</code>","text":"<p>Store a response, to be consumed later.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required <code>code</code> <code>int</code> <p>Code of the response.</p> required <code>response</code> <code>Any</code> <p>Content of the response.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>def store(self, req_id: str, code: int, response: Any):\n    \"\"\"Store a response, to be consumed later.\n\n    Args:\n        req_id (str): Request unique identifier.\n        code (int): Code of the response.\n        response (Any): Content of the response.\n    \"\"\"\n    # Store the response if the req_id is recognized\n    if req_id in self.req_states:\n        self.responses[req_id] = Response(code, response)\n\n        # Notify that we received the response\n        self.req_states[req_id].set()\n    else:\n        logger.warning(\n            f\"Request #{req_id} was previously removed from response buffer. \"\n            f\"Ignoring the response from this request...\"\n        )\n</code></pre>"},{"location":"code_ref/#gibbs.hub.RequestManager.wait_for","title":"<code>wait_for(req_id)</code>  <code>async</code>","text":"<p>Async method that waits until we received the response corresponding to the given request ID.</p> <p>The method <code>pin</code> should be called before waiting with this method.</p> <p>Parameters:</p> Name Type Description Default <code>req_id</code> <code>str</code> <p>Request unique identifier.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>Exception raised if the request wasn't registered previously.</p> <p>Returns:</p> Type Description <code>Tuple[int, Any]</code> <p>Tuple[int, Any]: Code and content of the received response.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def wait_for(self, req_id: str) -&gt; Tuple[int, Any]:\n    \"\"\"Async method that waits until we received the response corresponding\n    to the given request ID.\n\n    The method `pin` should be called before waiting with this method.\n\n    Args:\n        req_id (str): Request unique identifier.\n\n    Raises:\n        KeyError: Exception raised if the request wasn't registered previously.\n\n    Returns:\n        Tuple[int, Any]: Code and content of the received response.\n    \"\"\"\n    if req_id not in self.req_states:\n        raise KeyError(f\"Request #{req_id} was not pinned, or was removed because of buffer overflow\")\n\n    # Wait for the receiving loop to receive the response\n    await self.req_states[req_id].wait()\n\n    # Once we get it, access the result\n    r = self.responses.pop(req_id)\n\n    # Don't forget to remove the event\n    self.req_states.pop(req_id)\n\n    return r.code, r.content\n</code></pre>"},{"location":"code_ref/#gibbs.hub.UserCodeException","title":"<code>UserCodeException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom Exception for user-defined catched errors.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>str</code> <p>Traceback returned by the worker.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class UserCodeException(Exception):\n    \"\"\"Custom Exception for user-defined catched errors.\n\n    Args:\n        t (str): Traceback returned by the worker.\n    \"\"\"\n\n    def __init__(self, t: str):\n        super().__init__(f\"Exception raised in user-defined code. Traceback :\\n{t}\")\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager","title":"<code>WorkerManager</code>","text":"<p>A helper class that takes care of managing workers. Workers' address can be registered as available, and this class will make sure to return address of workers that are available and alive.</p> <p>A worker is considered as dead if we didn't receive any heartbeat within a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>heartbeat_interval</code> <code>float</code> <p>Interval of time (in seconds) after which we consider a worker to be dead.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>class WorkerManager:\n    \"\"\"A helper class that takes care of managing workers.\n    Workers' address can be registered as available, and this class will make\n    sure to return address of workers that are available and alive.\n\n    A worker is considered as dead if we didn't receive any heartbeat within a\n    given interval.\n\n    Args:\n        heartbeat_interval (float): Interval of time (in seconds) after which we\n            consider a worker to be dead.\n    \"\"\"\n\n    def __init__(self, heartbeat_interval: float):\n        super().__init__()\n\n        self.heartbeat_t = heartbeat_interval\n\n        self.w_ts = {}\n        self.w_access = asyncio.Condition()\n\n    async def reckon(self, address: str):\n        \"\"\"Register the given address as available.\n\n        Args:\n            address (str): Address of the worker to register as available.\n        \"\"\"\n        async with self.w_access:\n            self.w_ts[address] = time.time()\n            self.w_access.notify()\n\n    async def get_next_worker(self) -&gt; str:\n        \"\"\"Retrieve the next available and alive worker's address.\n\n        Returns:\n            str: Address of the available and alive worker.\n        \"\"\"\n        async with self.w_access:\n            # Iterate workers until we find one that was alive recently\n            w_alive = False\n            while not w_alive:\n                # If no workers are available, wait...\n                if not self.w_ts:\n                    await self.w_access.wait()\n\n                address, ts = self.w_ts.popitem()\n                w_alive = time.time() - ts &lt; self.heartbeat_t\n\n            return address\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager.get_next_worker","title":"<code>get_next_worker()</code>  <code>async</code>","text":"<p>Retrieve the next available and alive worker's address.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Address of the available and alive worker.</p> Source code in <code>gibbs/hub.py</code> <pre><code>async def get_next_worker(self) -&gt; str:\n    \"\"\"Retrieve the next available and alive worker's address.\n\n    Returns:\n        str: Address of the available and alive worker.\n    \"\"\"\n    async with self.w_access:\n        # Iterate workers until we find one that was alive recently\n        w_alive = False\n        while not w_alive:\n            # If no workers are available, wait...\n            if not self.w_ts:\n                await self.w_access.wait()\n\n            address, ts = self.w_ts.popitem()\n            w_alive = time.time() - ts &lt; self.heartbeat_t\n\n        return address\n</code></pre>"},{"location":"code_ref/#gibbs.hub.WorkerManager.reckon","title":"<code>reckon(address)</code>  <code>async</code>","text":"<p>Register the given address as available.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address of the worker to register as available.</p> required Source code in <code>gibbs/hub.py</code> <pre><code>async def reckon(self, address: str):\n    \"\"\"Register the given address as available.\n\n    Args:\n        address (str): Address of the worker to register as available.\n    \"\"\"\n    async with self.w_access:\n        self.w_ts[address] = time.time()\n        self.w_access.notify()\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker","title":"<code>Worker</code>","text":"<p>               Bases: <code>Process</code></p> <p>Define a worker process. This worker process indefinitely waits for requests on a socket. Upon receiving a request, it processes it with the worker class provided, and return the response.</p> <p>After creating the Worker object, you have 2 different ways to run it :  * <code>worker.run()</code> : It will run in the current process directly (blocking,     infinite loop).  * <code>worker.start()</code> : It will start a different process and start the code     there (non-blocking).</p> <p>Parameters:</p> Name Type Description Default <code>worker_cls</code> <code>Callable</code> <p>Worker class containing the code that will be used to process requests.</p> required <code>gibbs_host</code> <code>str</code> <p>Host of the Hub. Defaults to \"localhost\".</p> <code>'localhost'</code> <code>gibbs_port</code> <code>int</code> <p>Port of the Hub. Defaults to DEFAULT_PORT.</p> <code>DEFAULT_PORT</code> <code>gibbs_heartbeat_interval</code> <code>float</code> <p>Heartbeat interval between the worker and the Hub. Defaults to DEFAULT_HEARTBEAT_INTERVAL.</p> <code>DEFAULT_HEARTBEAT_INTERVAL</code> <code>gibbs_reset_after_n_miss</code> <code>int</code> <p>Number of missed heartbeats allowed before hard-resetting the socket and retrying. Defaults to DEFAULT_RESET_AFTER_N_MISS.</p> <code>DEFAULT_RESET_AFTER_N_MISS</code> Source code in <code>gibbs/worker.py</code> <pre><code>class Worker(Process):\n    \"\"\"Define a worker process. This worker process indefinitely waits for\n    requests on a socket. Upon receiving a request, it processes it with the\n    worker class provided, and return the response.\n\n    After creating the Worker object, you have 2 different ways to run it :\n     * `worker.run()` : It will run in the current process directly (blocking,\n        infinite loop).\n     * `worker.start()` : It will start a different process and start the code\n        there (non-blocking).\n\n    Args:\n        worker_cls (Callable): Worker class containing the code that will be used\n            to process requests.\n        gibbs_host (str): Host of the Hub. Defaults to \"localhost\".\n        gibbs_port (int): Port of the Hub. Defaults to DEFAULT_PORT.\n        gibbs_heartbeat_interval (float): Heartbeat interval between the\n            worker and the Hub. Defaults to DEFAULT_HEARTBEAT_INTERVAL.\n        gibbs_reset_after_n_miss (int): Number of missed heartbeats\n            allowed before hard-resetting the socket and retrying. Defaults to\n            DEFAULT_RESET_AFTER_N_MISS.\n    \"\"\"\n\n    def __init__(\n        self,\n        worker_cls: Callable,\n        *args: Any,\n        gibbs_host: str = \"localhost\",\n        gibbs_port: int = DEFAULT_PORT,\n        gibbs_heartbeat_interval: float = DEFAULT_HEARTBEAT_INTERVAL,\n        gibbs_reset_after_n_miss: int = DEFAULT_RESET_AFTER_N_MISS,\n        **kwargs: Any,\n    ):\n        super().__init__()\n\n        self.worker_cls = worker_cls\n        self.worker_args = args\n        self.worker_kwargs = kwargs\n\n        self.identity = uuid.uuid4().hex\n        self.host = gibbs_host\n        self.port = gibbs_port\n        self.heartbeat_t = gibbs_heartbeat_interval\n        self.reset_n_miss = gibbs_reset_after_n_miss\n\n        self.waiting_pong = 0\n\n    def create_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n        \"\"\"Helper method to create a socket, setting its identity and connecting\n        to the Hub.\n\n        Args:\n            context (zmq.Context): ZMQ context to use.\n\n        Returns:\n            zmq.Socket: Initialized and connected socket, ready to use.\n        \"\"\"\n        # Create the socket, set its identity\n        socket = context.socket(zmq.DEALER)\n        socket.setsockopt_string(zmq.IDENTITY, self.identity)\n\n        # Connect to the Hub\n        socket.connect(f\"tcp://{self.host}:{self.port}\")\n\n        return socket\n\n    def create_term_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n        \"\"\"Helper method to create a termination socket.\n\n        Basically it creates 2 sockets, bind/connect them together. One socket\n        will be used to send a termination signal, and the other is returned and\n        used to receive the termination signal.\n\n        Args:\n            context (zmq.Context): ZMQ context to use.\n\n        Returns:\n            zmq.Socket: Initialized and connected socket, ready to use.\n        \"\"\"\n        # Create the socket than will send the termination ping\n        term_snd_socket = context.socket(zmq.REQ)\n        port = term_snd_socket.bind_to_random_port(\"tcp://127.0.0.1\")\n\n        # Then define the behavior on how to send the termination ping\n        def send_term(*args, **kwargs):\n            logger.debug(\"Sending termination ping...\")\n            # Send something on the termination socket, it doesn't matter what\n            term_snd_socket.send(PING)\n\n        # We send the termination ping upon receiving these signals\n        signal.signal(signal.SIGTERM, send_term)\n        signal.signal(signal.SIGINT, send_term)\n\n        # And finally create the socket that we will use to receive the termination signal\n        term_rcv_socket = context.socket(zmq.REP)\n        term_rcv_socket.connect(f\"tcp://localhost:{port}\")\n\n        return term_rcv_socket\n\n    def reset_socket(self, socket: zmq.Socket, context: zmq.Context, poller: zmq.Poller) -&gt; zmq.Socket:\n        \"\"\"Helper method to reset the given socket.\n\n        This method unregister the socket from the given poller, close the\n        socket, and then recreate the socket and register this new socket in the\n        poller.\n\n        Args:\n            socket (zmq.Socket): ZMQ socket to reset.\n            context (zmq.Context): ZMQ context to use.\n            poller (zmq.Poller): ZMQ poller where the socket is registered.\n\n        Returns:\n            zmq.Socket: Initialized and connected socket, ready to use.\n        \"\"\"\n        # Close the existing socket\n        poller.unregister(socket)\n        socket.close(linger=0)\n\n        # Recreate the socket\n        socket = self.create_socket(context)\n        poller.register(socket, zmq.POLLIN)\n\n        return socket\n\n    def ping(self, socket: zmq.Socket):\n        \"\"\"Helper method used for the heartbeat. Also takes care of keeping the\n        counter of heartbeats up-to-date.\n\n        Args:\n            socket (zmq.Socket): Socket to use to send the heartbeat.\n        \"\"\"\n        logger.debug(\"Sending ping...\")\n        socket.send(PING)\n        self.waiting_pong += 1\n\n    def run(self):\n        \"\"\"Main method. It will initialize the worker class, and enter an\n        infinite loop, waiting for requests. Whenever a request is received, it\n        processes it with the code provided in the constructor.\n        \"\"\"\n        # Instanciate the worker\n        worker = self.worker_cls(*self.worker_args, **self.worker_kwargs)\n\n        # Initialize what we need for handling sockets\n        context = zmq.Context()\n        poller = zmq.Poller()\n\n        # Create the socket for termination\n        term_socket = self.create_term_socket(context)\n        poller.register(term_socket, zmq.POLLIN)\n\n        # Create the socket connecting to the hub\n        socket = self.create_socket(context)\n        poller.register(socket, zmq.POLLIN)\n\n        logger.info(\"Worker ready to roll\")\n\n        # Tell the Hub we are ready\n        self.ping(socket)\n\n        # Indefinitely wait for requests : when we are done with one request,\n        # we wait for the next one\n        while True:\n            logger.debug(\"Waiting for request...\")\n            events = dict(poller.poll(self.heartbeat_t * MS))\n\n            if term_socket in events:\n                logger.debug(\"Termination signal received, shutting down gracefully\")\n                break\n\n            if socket in events:\n                _, workload = socket.recv_multipart(zmq.NOBLOCK)\n                logger.debug(\"Received something !\")\n                self.waiting_pong = 0\n            else:\n                logger.debug(f\"Didn't receive anything for {self.heartbeat_t}s ({self.waiting_pong})\")\n\n                if self.waiting_pong &gt;= self.reset_n_miss:\n                    logger.warning(\n                        f\"The Hub is not answering, even after {self.waiting_pong} missed pings... \"\n                        f\"Resetting the socket\"\n                    )\n                    socket = self.reset_socket(socket=socket, context=context, poller=poller)\n                    self.waiting_pong = 0\n\n                # We didn't receive anything for some time, try to ping again\n                self.ping(socket)\n                continue\n\n            if workload == PONG:\n                # Just a Pong, ignore it\n                logger.debug(\"It was just a pong...\")\n                continue\n\n            # From here the Hub sent us an actual request\n            req_id, req_args, req_kwargs = msgpack.unpackb(workload)\n            logger.debug(f\"Request #{req_id} received\")\n\n            # Call worker's code with the request arguments\n            try:\n                res = worker(*req_args, **req_kwargs)\n            except Exception as e:\n                logger.warning(f\"Exception in user-defined __call__ method : {e.__class__.__name__}({str(e)})\")\n                socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_FAILURE, traceback.format_exc()])])\n            else:\n                logger.debug(\"Sending back the response\")\n                socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_SUCCESS, res])])\n\n        logger.info(\"Worker is shut down\")\n        quit()\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.create_socket","title":"<code>create_socket(context)</code>","text":"<p>Helper method to create a socket, setting its identity and connecting to the Hub.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>ZMQ context to use.</p> required <p>Returns:</p> Type Description <code>Socket</code> <p>zmq.Socket: Initialized and connected socket, ready to use.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def create_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n    \"\"\"Helper method to create a socket, setting its identity and connecting\n    to the Hub.\n\n    Args:\n        context (zmq.Context): ZMQ context to use.\n\n    Returns:\n        zmq.Socket: Initialized and connected socket, ready to use.\n    \"\"\"\n    # Create the socket, set its identity\n    socket = context.socket(zmq.DEALER)\n    socket.setsockopt_string(zmq.IDENTITY, self.identity)\n\n    # Connect to the Hub\n    socket.connect(f\"tcp://{self.host}:{self.port}\")\n\n    return socket\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.create_term_socket","title":"<code>create_term_socket(context)</code>","text":"<p>Helper method to create a termination socket.</p> <p>Basically it creates 2 sockets, bind/connect them together. One socket will be used to send a termination signal, and the other is returned and used to receive the termination signal.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>ZMQ context to use.</p> required <p>Returns:</p> Type Description <code>Socket</code> <p>zmq.Socket: Initialized and connected socket, ready to use.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def create_term_socket(self, context: zmq.Context) -&gt; zmq.Socket:\n    \"\"\"Helper method to create a termination socket.\n\n    Basically it creates 2 sockets, bind/connect them together. One socket\n    will be used to send a termination signal, and the other is returned and\n    used to receive the termination signal.\n\n    Args:\n        context (zmq.Context): ZMQ context to use.\n\n    Returns:\n        zmq.Socket: Initialized and connected socket, ready to use.\n    \"\"\"\n    # Create the socket than will send the termination ping\n    term_snd_socket = context.socket(zmq.REQ)\n    port = term_snd_socket.bind_to_random_port(\"tcp://127.0.0.1\")\n\n    # Then define the behavior on how to send the termination ping\n    def send_term(*args, **kwargs):\n        logger.debug(\"Sending termination ping...\")\n        # Send something on the termination socket, it doesn't matter what\n        term_snd_socket.send(PING)\n\n    # We send the termination ping upon receiving these signals\n    signal.signal(signal.SIGTERM, send_term)\n    signal.signal(signal.SIGINT, send_term)\n\n    # And finally create the socket that we will use to receive the termination signal\n    term_rcv_socket = context.socket(zmq.REP)\n    term_rcv_socket.connect(f\"tcp://localhost:{port}\")\n\n    return term_rcv_socket\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.ping","title":"<code>ping(socket)</code>","text":"<p>Helper method used for the heartbeat. Also takes care of keeping the counter of heartbeats up-to-date.</p> <p>Parameters:</p> Name Type Description Default <code>socket</code> <code>Socket</code> <p>Socket to use to send the heartbeat.</p> required Source code in <code>gibbs/worker.py</code> <pre><code>def ping(self, socket: zmq.Socket):\n    \"\"\"Helper method used for the heartbeat. Also takes care of keeping the\n    counter of heartbeats up-to-date.\n\n    Args:\n        socket (zmq.Socket): Socket to use to send the heartbeat.\n    \"\"\"\n    logger.debug(\"Sending ping...\")\n    socket.send(PING)\n    self.waiting_pong += 1\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.reset_socket","title":"<code>reset_socket(socket, context, poller)</code>","text":"<p>Helper method to reset the given socket.</p> <p>This method unregister the socket from the given poller, close the socket, and then recreate the socket and register this new socket in the poller.</p> <p>Parameters:</p> Name Type Description Default <code>socket</code> <code>Socket</code> <p>ZMQ socket to reset.</p> required <code>context</code> <code>Context</code> <p>ZMQ context to use.</p> required <code>poller</code> <code>Poller</code> <p>ZMQ poller where the socket is registered.</p> required <p>Returns:</p> Type Description <code>Socket</code> <p>zmq.Socket: Initialized and connected socket, ready to use.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def reset_socket(self, socket: zmq.Socket, context: zmq.Context, poller: zmq.Poller) -&gt; zmq.Socket:\n    \"\"\"Helper method to reset the given socket.\n\n    This method unregister the socket from the given poller, close the\n    socket, and then recreate the socket and register this new socket in the\n    poller.\n\n    Args:\n        socket (zmq.Socket): ZMQ socket to reset.\n        context (zmq.Context): ZMQ context to use.\n        poller (zmq.Poller): ZMQ poller where the socket is registered.\n\n    Returns:\n        zmq.Socket: Initialized and connected socket, ready to use.\n    \"\"\"\n    # Close the existing socket\n    poller.unregister(socket)\n    socket.close(linger=0)\n\n    # Recreate the socket\n    socket = self.create_socket(context)\n    poller.register(socket, zmq.POLLIN)\n\n    return socket\n</code></pre>"},{"location":"code_ref/#gibbs.worker.Worker.run","title":"<code>run()</code>","text":"<p>Main method. It will initialize the worker class, and enter an infinite loop, waiting for requests. Whenever a request is received, it processes it with the code provided in the constructor.</p> Source code in <code>gibbs/worker.py</code> <pre><code>def run(self):\n    \"\"\"Main method. It will initialize the worker class, and enter an\n    infinite loop, waiting for requests. Whenever a request is received, it\n    processes it with the code provided in the constructor.\n    \"\"\"\n    # Instanciate the worker\n    worker = self.worker_cls(*self.worker_args, **self.worker_kwargs)\n\n    # Initialize what we need for handling sockets\n    context = zmq.Context()\n    poller = zmq.Poller()\n\n    # Create the socket for termination\n    term_socket = self.create_term_socket(context)\n    poller.register(term_socket, zmq.POLLIN)\n\n    # Create the socket connecting to the hub\n    socket = self.create_socket(context)\n    poller.register(socket, zmq.POLLIN)\n\n    logger.info(\"Worker ready to roll\")\n\n    # Tell the Hub we are ready\n    self.ping(socket)\n\n    # Indefinitely wait for requests : when we are done with one request,\n    # we wait for the next one\n    while True:\n        logger.debug(\"Waiting for request...\")\n        events = dict(poller.poll(self.heartbeat_t * MS))\n\n        if term_socket in events:\n            logger.debug(\"Termination signal received, shutting down gracefully\")\n            break\n\n        if socket in events:\n            _, workload = socket.recv_multipart(zmq.NOBLOCK)\n            logger.debug(\"Received something !\")\n            self.waiting_pong = 0\n        else:\n            logger.debug(f\"Didn't receive anything for {self.heartbeat_t}s ({self.waiting_pong})\")\n\n            if self.waiting_pong &gt;= self.reset_n_miss:\n                logger.warning(\n                    f\"The Hub is not answering, even after {self.waiting_pong} missed pings... \"\n                    f\"Resetting the socket\"\n                )\n                socket = self.reset_socket(socket=socket, context=context, poller=poller)\n                self.waiting_pong = 0\n\n            # We didn't receive anything for some time, try to ping again\n            self.ping(socket)\n            continue\n\n        if workload == PONG:\n            # Just a Pong, ignore it\n            logger.debug(\"It was just a pong...\")\n            continue\n\n        # From here the Hub sent us an actual request\n        req_id, req_args, req_kwargs = msgpack.unpackb(workload)\n        logger.debug(f\"Request #{req_id} received\")\n\n        # Call worker's code with the request arguments\n        try:\n            res = worker(*req_args, **req_kwargs)\n        except Exception as e:\n            logger.warning(f\"Exception in user-defined __call__ method : {e.__class__.__name__}({str(e)})\")\n            socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_FAILURE, traceback.format_exc()])])\n        else:\n            logger.debug(\"Sending back the response\")\n            socket.send_multipart([b\"\", msgpack.packb([req_id, CODE_SUCCESS, res])])\n\n    logger.info(\"Worker is shut down\")\n    quit()\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>All examples are located in the <code>examples/</code> folder.</p> <p>All examples can be run directly without any arguments. You can experiment new settings by changing the constants inside the scripts.</p> <p>Important</p> <p>Some examples require additional dependencies. You can install these dependencies with <code>pip install gibbs[ex]</code> (see Installation)</p>"},{"location":"examples/#vanilla_fastapipy","title":"vanilla_fastapi.py","text":"<pre><code>python examples/vanilla_fastapi.py\n</code></pre> <p>This example simply creates a FastAPI application with a dummy model. The dummy model simulate some computations time.</p> <p>The script will measure the time needed to send and receive 10 requests.</p>"},{"location":"examples/#gibbs_fastapipy","title":"gibbs_fastapi.py","text":"<pre><code>python examples/gibbs_fastapi.py\n</code></pre> <p>This example is the same as <code>vanilla_fastapi.py</code>, but it uses <code>gibbs</code> to scale up the dummy model (with 2 workers).</p> <p>The script will also measure the time needed to send and receive 10 requests, so you can compare the results with the vanilla approach.</p>"},{"location":"examples/#transformerpy","title":"transformer.py","text":"<pre><code>python examples/transformer.py\n</code></pre> <p>A more \"real-life\" application, where we use a BART model (from <code>transformers</code> library) along with <code>gibbs</code> for scaling up text-summarization.</p>"},{"location":"usage/","title":"Usage","text":"<p>Let's walk-through an example of how to scale a FastAPI application together !</p> <p>Note</p> <p>Here we use FastAPI to show how easy it is to integrate <code>gibbs</code> in an asynchronous framework, but <code>gibbs</code> can be used like any asynchronous python code !</p>"},{"location":"usage/#initial-application","title":"Initial application","text":"<p>Let's take a simple example to see how we can scale with <code>gibbs</code>.</p> <p>Say we have developed a great ML model. For the simplicity of this example, here is the code of a dummy model :</p> <pre><code>import time\n\n\nclass MyAwesomeModel:\n    def __init__(self, wait_time=0.25):\n        super().__init__()\n        self.w = wait_time\n\n    def __call__(self, x):\n        time.sleep(self.w)\n        return x**2\n</code></pre> <p>This model simply return the squared input, after simulating a certain processing time.</p> <p>Now, having a model is great, but we want to make it available to our users. To do that, we create an API using FastAPI, serving that model. Here is the code :</p> <pre><code>import time\n\nimport uvicorn\nfrom fastapi import FastAPI\n\n\nclass MyAwesomeModel:\n    def __init__(self, wait_time=0.25):\n        super().__init__()\n        self.w = wait_time\n\n    def __call__(self, x):\n        time.sleep(self.w)\n        return x**2\n\n\n# Instanciate FastAPI app and instanciate our model\napp = FastAPI()\nmodel = MyAwesomeModel()\n\n\n# Define a route that will call our model and return the result\n@app.get(\"/request\")\nasync def simple_request(x: int):\n    return {\"result\": model(x)}\n\n\nif __name__==\"__main__\":\n    # Run the app\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>You can run this python script and access http://localhost:8000/docs to try the route by yourself.</p> <p>Great ! We are serving our awesome model !</p>"},{"location":"usage/#the-scaling-issue","title":"The scaling issue","text":"<p>This code is great, but it does not scale.</p> <p>Because our model takes <code>250ms</code> to deal with every request, you can imagine what happen when 10 clients send one request at the same time... One of the client will have to wait <code>2.5s</code> before receiving a response !</p> <p>You can try this out by starting our simple app, and in another terminal, run the following script :</p> <pre><code>import multiprocessing as mp\nimport time\n\nimport requests\n\n\ndef req_process(i):\n    r = requests.get(f\"http://localhost:8000/request?x={i}\")\n    assert r.status_code == 200\n    return r.json()\n\n\ndef time_parallel_requests(n):\n    with mp.Pool(n) as p:\n        t0 = time.time()\n        p.map(req_process, range(n))\n        t1 = time.time()\n\n    return t1 - t0\n\n\nif __name__ == \"__main__\":\n    t = time_parallel_requests(10)\n    print(f\"It tooks {t:.3f}s to process 10 requests\")\n</code></pre> <p>This script simply run 10 requests in parallel and print the time necessary to complete all of them. And as expected :</p> <p>It tooks 2.532s to process 10 requests</p>"},{"location":"usage/#how-gibbs-works","title":"How <code>gibbs</code> works","text":"<p>What we want is simply to have pool of several models, and when one model is busy dealing with a request, instead of waiting for it to finish, we want to call another (idle) model.</p> <p>So we can deal with several requests in parallel, and therefore serve several clients with a low latency !</p> <p>To achieve this, <code>gibbs</code> introduces 2 classes :</p> <ul> <li><code>Hub</code></li> <li><code>Worker</code></li> </ul> <p>The <code>Worker</code> class is just a process, dealing with requests sequentially by calling the awesome model you created.</p> <p>The <code>Hub</code> is the class that orchestrate the requests, sending each request to the right worker (currently idle).</p> <p>Hint</p> <p>You can see a more detailed description of how this work in Architecture</p>"},{"location":"usage/#use-gibbs-to-scale-up","title":"Use <code>gibbs</code> to scale up","text":"<p>Let's see how to modify our simple app to scale up.</p> <p>We simply have to create a <code>Hub</code> and use it to send requests, and start a few workers with our awesome model !</p> <pre><code>import time\n\nimport uvicorn\nfrom fastapi import FastAPI\n\nfrom gibbs import Hub, Worker\n\n\nclass MyAwesomeModel:\n    def __init__(self, wait_time=0.25):\n        super().__init__()\n        self.w = wait_time\n\n    def __call__(self, x):\n        time.sleep(self.w)\n        return x**2\n\n\n# Instanciate FastAPI app and instanciate the Hub\napp = FastAPI()\nhub = Hub()\n\n\n# Define a route that will call our model and return the result\n@app.get(\"/request\")\nasync def simple_request(x: int):\n    return {\"result\": await hub.request(x)}\n\n\nif __name__==\"__main__\":\n    # Start the workers (in another process)\n    workers = [Worker(MyAwesomeModel) for _ in range(4)]\n    for w in workers:\n        w.start()\n\n    # Run the app\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Quite simple, right ?</p> <p>Now, if we use the same script as before to run 10 requests in parallel in another terminal :</p> <p>It tooks 0.855s to process 10 requests</p> <p>The time needed to deal with 10 requests is greatly reduced, by sharing the work between the 4 workers !</p>"}]}